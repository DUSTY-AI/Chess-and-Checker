<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü–†–û–ï–ö–¢ 1430 - –í–µ–± –≤–µ—Ä—Å–∏—è</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            font-size: clamp(2.2rem, 6vw, 3.5rem);
            margin-bottom: 12px;
            color: #0072ff;
            text-shadow: 0 0 20px rgba(0, 114, 255, 0.8);
            word-wrap: break-word;
            text-align: center;
            width: 100%;
        }
        
        .subtitle {
            color: #ff6b6b;
            font-size: clamp(1.3rem, 3.5vw, 1.8rem);
            margin-bottom: 20px;
            text-align: center;
            width: 100%;
            font-weight: bold;
            text-shadow: 0 2px 10px rgba(255, 107, 107, 0.5);
        }
        
        .welcome-section {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .welcome-container {
            background: rgba(73, 119, 248, 0.15);
            border-radius: 12px;
            border: 2px solid rgba(73, 119, 248, 0.3);
            backdrop-filter: blur(5px);
            padding: 18px 25px;
            display: inline-block;
            max-width: 100%;
            box-shadow: 0 5px 15px rgba(73, 119, 248, 0.2);
            text-align: center;
        }
        
        .welcome-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 6px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            line-height: 1.3;
        }
        
        .welcome-subtext {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            line-height: 1.3;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 1500px;
            flex: 1;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            align-items: center;
        }
        
        .game-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
        }
        
        .game-window {
            border: 5px solid #0072ff;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 114, 255, 0.6);
            background: #0a0a1a;
            width: 700px;
            height: 700px;
            position: relative;
            margin: 0 auto;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .game-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 700px;
        }
        
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 26, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            padding: 20px;
        }
        
        .menu-content {
            background: linear-gradient(135deg, rgba(15, 52, 96, 0.98) 0%, rgba(0, 114, 255, 0.9) 100%);
            border-radius: 20px;
            padding: 35px 30px;
            width: 100%;
            height: 100%;
            max-height: 100%;
            max-width: 100%;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.9);
            border: 4px solid rgba(255, 255, 255, 0.25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        .menu-header {
            margin-bottom: 25px;
            text-align: center;
            padding-bottom: 15px;
            border-bottom: 3px solid rgba(255, 255, 255, 0.35);
        }
        
        .menu-title {
            font-size: 2.5rem;
            margin-bottom: 15px;
            color: white;
            text-shadow: 0 3px 10px rgba(0, 0, 0, 0.8);
        }
        
        .menu-subtitle {
            font-size: 1.3rem;
            color: rgba(255, 255, 255, 0.95);
        }
        
        .menu-buttons-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 18px;
            overflow-y: auto;
            padding: 15px;
            margin: 0 -10px;
        }
        
        .menu-button {
            display: block;
            width: 100%;
            padding: 22px;
            margin: 2px 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.2) 100%);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 1.6rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            border: 3px solid rgba(255, 255, 255, 0.35);
            min-height: 85px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .menu-button:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.35) 0%, rgba(255, 255, 255, 0.3) 100%);
            transform: translateY(-4px);
            box-shadow: 0 10px 20px rgba(0, 114, 255, 0.7);
        }
        
        .menu-button:active {
            transform: translateY(0);
        }
        
        .menu-button.small {
            padding: 18px;
            font-size: 1.4rem;
            min-height: 70px;
        }
        
        .close-menu {
            display: none;
        }
        
        .game-select-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin: 20px 0;
        }
        
        .game-select-button {
            background: linear-gradient(135deg, rgba(0, 114, 255, 0.45) 0%, rgba(0, 198, 255, 0.35) 100%);
            border: 4px solid rgba(0, 114, 255, 0.7);
            border-radius: 20px;
            padding: 25px;
            color: white;
            font-size: 1.6rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            text-align: center;
            height: 200px;
        }
        
        .game-select-button:hover {
            background: linear-gradient(135deg, rgba(0, 114, 255, 0.7) 0%, rgba(0, 198, 255, 0.6) 100%);
            transform: translateY(-6px);
            box-shadow: 0 15px 30px rgba(0, 114, 255, 0.6);
        }
        
        .game-icon {
            font-size: 4rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
        }
        
        .checkers-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
            background: #ffffff;
            border-radius: 50%;
            border: 5px solid #000000;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .content-container {
            flex: 1;
            overflow-y: auto;
            margin: 20px 0;
            padding-right: 15px;
        }
        
        .content-container::-webkit-scrollbar {
            width: 10px;
        }
        
        .content-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 5px;
        }
        
        .content-container::-webkit-scrollbar-thumb {
            background: rgba(0, 114, 255, 0.7);
            border-radius: 5px;
        }
        
        .achievement-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.2) 100%);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            border-left: 8px solid;
            border-image: linear-gradient(to bottom, #0072ff, #00c6ff) 1;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .achievement-item.unlocked {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.3) 0%, rgba(39, 174, 96, 0.25) 100%);
            border-left: 8px solid;
            border-image: linear-gradient(to bottom, #2ecc71, #27ae60) 1;
            box-shadow: 0 5px 20px rgba(46, 204, 113, 0.3);
        }
        
        .achievement-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 114, 255, 0.4);
        }
        
        .achievement-item.unlocked:hover {
            box-shadow: 0 10px 25px rgba(46, 204, 113, 0.4);
        }
        
        .achievement-icon {
            font-size: 2.5rem;
            margin-right: 15px;
            vertical-align: middle;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        .achievement-name {
            font-weight: bold;
            font-size: 1.4rem;
            margin-bottom: 8px;
            color: white;
            text-shadow: 0 2px 3px rgba(0, 0, 0, 0.5);
        }
        
        .achievement-desc {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.95);
            margin-bottom: 10px;
        }
        
        .progress-bar {
            height: 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            overflow: hidden;
            margin-top: 10px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0072ff, #00c6ff);
            border-radius: 6px;
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(0, 114, 255, 0.5);
        }
        
        .progress-text {
            text-align: right;
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.95);
            margin-top: 8px;
            font-weight: bold;
        }
        
        .stat-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.2) 100%);
            border-radius: 15px;
            padding: 25px;
            margin: 15px 0;
            border-left: 8px solid;
            border-image: linear-gradient(to bottom, #00c6ff, #0072ff) 1;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .stat-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 198, 255, 0.4);
        }
        
        .stat-name {
            font-weight: bold;
            font-size: 1.4rem;
            margin-bottom: 10px;
            color: white;
            text-shadow: 0 2px 3px rgba(0, 0, 0, 0.5);
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 2px 8px rgba(255, 204, 0, 0.5);
        }
        
        .instructions-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.2) 100%);
            border-radius: 15px;
            padding: 25px;
            margin: 15px 0;
            border: 3px solid rgba(0, 198, 255, 0.3);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        
        .instructions-content:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 198, 255, 0.3);
        }
        
        .instructions-content h3 {
            color: #4977F8;
            margin-bottom: 20px;
            font-size: 1.7rem;
            border-bottom: 3px solid rgba(73, 119, 248, 0.7);
            padding-bottom: 10px;
            text-shadow: 0 2px 3px rgba(0, 0, 0, 0.5);
        }
        
        .instructions-content ul {
            list-style: none;
            padding-left: 10px;
        }
        
        .instructions-content li {
            margin-bottom: 15px;
            padding-left: 30px;
            position: relative;
            font-size: 1.3rem;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.95);
        }
        
        .instructions-content li:before {
            content: "‚ú¶";
            color: #0072ff;
            position: absolute;
            left: 0;
            font-size: 1.8rem;
            text-shadow: 0 0 10px rgba(0, 114, 255, 0.7);
        }
        
        .setting-item {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 25px;
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .setting-item-with-volume {
            flex-direction: column;
            align-items: flex-start;
            gap: 15px;
        }
        
        .setting-label {
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .setting-label i {
            font-size: 1.8rem;
        }
        
        .volume-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 100%;
        }
        
        .volume-slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .volume-slider {
            flex: 1;
            height: 12px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            outline: none;
            cursor: pointer;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #0072ff;
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 0 10px rgba(0, 114, 255, 0.7);
        }
        
        .volume-slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #0072ff;
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 0 10px rgba(0, 114, 255, 0.7);
        }
        
        .volume-value {
            min-width: 45px;
            text-align: center;
            font-weight: bold;
            font-size: 1.2rem;
            color: #4977F8;
        }
        
        .setting-toggle {
            position: relative;
            width: 70px;
            height: 35px;
        }
        
        .setting-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .setting-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.3);
            transition: .4s;
            border-radius: 35px;
        }
        
        .setting-slider:before {
            position: absolute;
            content: "";
            height: 27px;
            width: 27px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        .setting-toggle input:checked + .setting-slider {
            background-color: #0072ff;
        }
        
        .setting-toggle input:checked + .setting-slider:before {
            transform: translateX(35px);
        }
        
        .controls {
            display: none;
        }
        
        .stats {
            display: none;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 22px;
            border-radius: 15px;
            border-left: 6px solid #0072ff;
            text-align: center;
            min-height: 110px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .stat-card h3 {
            color: #0072ff;
            margin-bottom: 10px;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-card p {
            font-size: 2rem;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 2px 8px rgba(255, 204, 0, 0.5);
        }
        
        .status-bar {
            display: none;
        }
        
        .score-board {
            display: none !important;
        }
        
        .score {
            text-align: center;
            flex: 1;
        }
        
        .score-value {
            font-size: 2rem;
            font-weight: bold;
            color: white;
        }
        
        .score-label {
            font-size: 1.3rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .action-button {
            width: 100%;
            padding: 25px;
            background: linear-gradient(135deg, #0072ff 0%, #00c6ff 100%);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.6rem;
            transition: all 0.3s ease;
            margin-top: 15px;
            border: 4px solid rgba(255, 255, 255, 0.25);
        }
        
        .action-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 114, 255, 0.7);
        }
        
        .action-button.red {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
            border-color: rgba(255, 255, 255, 0.25);
        }
        
        .achievement-notification {
            position: fixed;
            top: 30px;
            right: 30px;
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
            padding: 20px 25px;
            border-radius: 15px;
            box-shadow: 0 15px 40px rgba(46, 204, 113, 0.7);
            z-index: 1000;
            animation: slideInRight 0.5s ease, slideOutRight 0.5s ease 4.5s forwards;
            max-width: min(400px, 90vw);
            border: 4px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            gap: 15px;
            backdrop-filter: blur(10px);
        }
        
        .achievement-notification-content {
            flex: 1;
        }
        
        .achievement-notification-icon {
            font-size: 3rem;
            filter: drop-shadow(0 3px 5px rgba(0, 0, 0, 0.3));
        }
        
        .achievement-notification-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 2px 3px rgba(0, 0, 0, 0.3);
        }
        
        .achievement-notification-desc {
            font-size: 1.1rem;
            opacity: 0.95;
        }
        
        .achievement-notification.rarity-common {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            box-shadow: 0 15px 40px rgba(52, 152, 219, 0.7);
        }
        
        .achievement-notification.rarity-rare {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            box-shadow: 0 15px 40px rgba(155, 89, 182, 0.7);
        }
        
        .achievement-notification.rarity-epic {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            box-shadow: 0 15px 40px rgba(231, 76, 60, 0.7);
        }
        
        .achievement-notification.rarity-legendary {
            background: linear-gradient(135deg, #f39c12 0%, #d35400 100%);
            box-shadow: 0 15px 40px rgba(243, 156, 18, 0.7);
        }
        
        .achievement-notification.rarity-mythic {
            background: linear-gradient(135deg, #ff00ff 0%, #9400d3 100%);
            box-shadow: 0 15px 40px rgba(255, 0, 255, 0.7);
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .achievement-item.new {
            animation: pulse 1s ease 3;
        }
        
        .notification {
            position: fixed;
            top: 30px;
            right: 30px;
            background: linear-gradient(135deg, #0072ff 0%, #00c6ff 100%);
            color: white;
            padding: 20px 25px;
            border-radius: 15px;
            box-shadow: 0 15px 40px rgba(0, 114, 255, 0.7);
            z-index: 1000;
            animation: slideInRight 0.5s ease, slideOutRight 0.5s ease 2.5s forwards;
            max-width: min(400px, 90vw);
            border: 4px solid rgba(255, 255, 255, 0.3);
        }
        
        .notification h4 {
            font-size: 1.5rem;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .notification p {
            font-size: 1.1rem;
            opacity: 0.95;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 500px;
            gap: 25px;
        }
        
        .spinner {
            width: 70px;
            height: 70px;
            border: 6px solid rgba(0, 114, 255, 0.3);
            border-top-color: #0072ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        
        .hidden {
            display: none !important;
        }
        
        .back-to-mode-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.2) 100%);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 10px 18px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 5;
            border: 2px solid rgba(255, 255, 255, 0.35);
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0.9;
        }
        
        .back-to-mode-btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.35) 0%, rgba(255, 255, 255, 0.3) 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 114, 255, 0.5);
            opacity: 1;
        }
        
        .promotion-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 26, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            padding: 20px;
        }
        
        .promotion-content {
            background: linear-gradient(135deg, rgba(15, 52, 96, 0.98) 0%, rgba(0, 114, 255, 0.9) 100%);
            border-radius: 20px;
            padding: 30px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.9);
            border: 4px solid rgba(255, 255, 255, 0.25);
            text-align: center;
        }
        
        .promotion-title {
            font-size: 2rem;
            margin-bottom: 25px;
            color: white;
            text-shadow: 0 3px 10px rgba(0, 0, 0, 0.8);
        }
        
        .promotion-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 25px 0;
        }
        
        .promotion-button {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.2) 100%);
            border: 3px solid rgba(255, 255, 255, 0.35);
            border-radius: 15px;
            padding: 25px;
            color: white;
            font-size: 1.6rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            text-align: center;
            height: 150px;
        }
        
        .promotion-button:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.35) 0%, rgba(255, 255, 255, 0.3) 100%);
            transform: translateY(-4px);
            box-shadow: 0 10px 20px rgba(0, 114, 255, 0.7);
        }
        
        .promotion-icon {
            font-size: 3.5rem;
        }
        
        /* –°—Ç–∏–ª–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —à–∞—Ö–∞ –∏ –º–∞—Ç–∞ */
        .checkmate-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(255, 50, 50, 0.95) 0%, rgba(200, 0, 0, 0.9) 100%);
            color: white;
            padding: 30px 40px;
            border-radius: 20px;
            box-shadow: 0 20px 50px rgba(255, 0, 0, 0.7);
            z-index: 100;
            text-align: center;
            min-width: 350px;
            max-width: 500px;
            border: 5px solid rgba(255, 255, 255, 0.4);
            animation: popIn 0.5s ease;
        }
        
        .check-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(255, 204, 0, 0.95) 0%, rgba(255, 136, 0, 0.9) 100%);
            color: white;
            padding: 25px 35px;
            border-radius: 20px;
            box-shadow: 0 20px 50px rgba(255, 204, 0, 0.7);
            z-index: 100;
            text-align: center;
            min-width: 300px;
            max-width: 450px;
            border: 5px solid rgba(255, 255, 255, 0.4);
            animation: popIn 0.5s ease;
        }
        
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        @keyframes popOut {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
        }
        
        .checkmate-notification h3 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            text-shadow: 0 3px 5px rgba(0, 0, 0, 0.5);
        }
        
        .checkmate-notification p {
            font-size: 1.5rem;
            opacity: 0.95;
        }
        
        .check-notification h3 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            text-shadow: 0 3px 5px rgba(0, 0, 0, 0.5);
        }
        
        .check-notification p {
            font-size: 1.3rem;
            opacity: 0.95;
        }
        
        @media (max-width: 768px) {
            .game-window {
                width: 600px;
                height: 600px;
            }
            
            .menu-button {
                padding: 18px;
                font-size: 1.4rem;
                min-height: 75px;
            }
            
            .game-select-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .game-select-button {
                padding: 25px;
                font-size: 1.6rem;
                height: 200px;
            }
            
            .game-icon {
                font-size: 3.5rem;
                width: 70px;
                height: 70px;
            }
            
            .checkers-icon {
                width: 70px;
                height: 70px;
                border-width: 4px;
            }
            
            .menu-title {
                font-size: 2.2rem;
            }
            
            .menu-content {
                padding: 25px;
            }
            
            .welcome-container {
                padding: 15px 20px;
            }
            
            .welcome-text {
                font-size: 1.3rem;
            }
            
            .welcome-subtext {
                font-size: 1rem;
            }
            
            .back-to-mode-btn {
                top: 15px;
                left: 15px;
                padding: 8px 15px;
                font-size: 1rem;
            }
            
            .menu-overlay {
                padding: 15px;
            }
            
            .achievement-notification {
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                max-width: calc(100vw - 40px);
            }
            
            .achievement-notification-icon {
                font-size: 2.5rem;
            }
            
            .setting-item {
                padding: 20px;
            }
            
            .setting-label {
                font-size: 1.3rem;
            }
            
            .stat-value {
                font-size: 2.2rem;
            }
            
            .promotion-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .promotion-button {
                padding: 20px;
                font-size: 1.4rem;
                height: 130px;
            }
            
            .promotion-icon {
                font-size: 3rem;
            }
            
            .checkmate-notification {
                min-width: 280px;
                padding: 20px 25px;
            }
            
            .checkmate-notification h3 {
                font-size: 1.8rem;
            }
            
            .checkmate-notification p {
                font-size: 1.2rem;
            }
            
            .check-notification {
                min-width: 250px;
                padding: 18px 22px;
            }
            
            .check-notification h3 {
                font-size: 1.6rem;
            }
            
            .check-notification p {
                font-size: 1.1rem;
            }
        }
        
        @media (max-width: 650px) {
            body {
                padding: 15px;
            }
            
            .game-window {
                width: 550px;
                height: 550px;
            }
            
            .menu-button {
                padding: 16px;
                font-size: 1.3rem;
                min-height: 70px;
            }
            
            .menu-title {
                font-size: 2rem;
            }
            
            .menu-subtitle {
                font-size: 1.3rem;
            }
            
            .menu-content {
                padding: 20px;
            }
            
            .welcome-container {
                padding: 12px 18px;
                border-radius: 10px;
            }
            
            .welcome-text {
                font-size: 1.2rem;
            }
            
            .welcome-subtext {
                font-size: 0.9rem;
            }
            
            .game-select-button {
                height: 180px;
                padding: 22px;
                font-size: 1.5rem;
            }
            
            .game-icon {
                font-size: 3rem;
                width: 60px;
                height: 60px;
            }
            
            .checkers-icon {
                width: 60px;
                height: 60px;
                border-width: 4px;
            }
            
            .back-to-mode-btn {
                top: 12px;
                left: 12px;
                padding: 6px 12px;
                font-size: 0.9rem;
            }
            
            .achievement-notification {
                flex-direction: column;
                text-align: center;
                gap: 10px;
            }
            
            .stat-name {
                font-size: 1.2rem;
            }
            
            .stat-value {
                font-size: 2rem;
            }
            
            .achievement-name {
                font-size: 1.2rem;
            }
            
            .achievement-desc {
                font-size: 1rem;
            }
            
            .instructions-content h3 {
                font-size: 1.5rem;
            }
            
            .instructions-content li {
                font-size: 1.1rem;
            }
            
            .setting-item {
                padding: 18px;
            }
            
            .setting-label {
                font-size: 1.2rem;
            }
            
            .promotion-title {
                font-size: 1.8rem;
            }
            
            .promotion-button {
                height: 120px;
                padding: 18px;
                font-size: 1.3rem;
            }
            
            .promotion-icon {
                font-size: 2.8rem;
            }
        }
        
        @media (max-width: 580px) {
            .game-window {
                width: 500px;
                height: 500px;
            }
            
            .menu-button {
                padding: 14px;
                font-size: 1.2rem;
                min-height: 65px;
            }
            
            .menu-title {
                font-size: 1.8rem;
            }
            
            .game-select-button {
                height: 170px;
                padding: 20px;
                font-size: 1.4rem;
            }
            
            .game-icon {
                font-size: 2.8rem;
                width: 55px;
                height: 55px;
            }
            
            .checkers-icon {
                width: 55px;
                height: 55px;
                border-width: 3px;
            }
            
            .back-to-mode-btn {
                top: 10px;
                left: 10px;
                padding: 5px 10px;
                font-size: 0.8rem;
            }
            
            .stat-value {
                font-size: 1.8rem;
            }
        }
        
        @media (max-width: 530px) {
            h1 {
                font-size: 2rem;
            }
            
            .subtitle {
                font-size: 1.4rem;
            }
            
            .game-window {
                width: 450px;
                height: 450px;
            }
            
            .menu-button {
                padding: 12px;
                font-size: 1.1rem;
                min-height: 60px;
            }
            
            .menu-title {
                font-size: 1.6rem;
            }
            
            .menu-content {
                padding: 18px;
            }
            
            .game-select-button {
                height: 160px;
                padding: 18px;
                font-size: 1.3rem;
            }
            
            .game-icon {
                font-size: 2.5rem;
                width: 50px;
                height: 50px;
            }
            
            .checkers-icon {
                width: 50px;
                height: 50px;
                border-width: 3px;
            }
            
            .welcome-container {
                padding: 10px 15px;
            }
            
            .welcome-text {
                font-size: 1.1rem;
            }
            
            .welcome-subtext {
                font-size: 0.85rem;
            }
            
            .achievement-notification {
                padding: 12px 16px;
            }
            
            .achievement-notification-title {
                font-size: 1.3rem;
            }
            
            .achievement-notification-desc {
                font-size: 1rem;
            }
            
            .stat-value {
                font-size: 1.6rem;
            }
        }
        
        @media (max-width: 480px) {
            .game-window {
                width: 400px;
                height: 400px;
            }
            
            .menu-button {
                padding: 10px;
                font-size: 1rem;
                min-height: 55px;
            }
            
            .menu-title {
                font-size: 1.5rem;
            }
            
            .game-select-button {
                height: 150px;
                padding: 16px;
                font-size: 1.2rem;
            }
            
            .game-icon {
                font-size: 2.2rem;
                width: 45px;
                height: 45px;
            }
            
            .checkers-icon {
                width: 45px;
                height: 45px;
                border-width: 2px;
            }
            
            .welcome-container {
                padding: 8px 12px;
            }
            
            .welcome-text {
                font-size: 1rem;
            }
            
            .welcome-subtext {
                font-size: 0.8rem;
            }
            
            .promotion-grid {
                gap: 12px;
            }
            
            .promotion-button {
                padding: 16px;
                font-size: 1.2rem;
                height: 110px;
            }
            
            .promotion-icon {
                font-size: 2.5rem;
            }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-25px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.4s ease;
        }
        
        @keyframes kingGlow {
            0% { box-shadow: 0 0 5px rgba(255, 0, 0, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 0, 0, 0.9); }
            100% { box-shadow: 0 0 5px rgba(255, 0, 0, 0.5); }
        }
        
        @keyframes kingPulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .king-check {
            animation: kingGlow 1s infinite, kingPulse 1s infinite;
        }
        
        @keyframes checkFlash {
            0% { background-color: rgba(255, 50, 50, 0.3); }
            50% { background-color: rgba(255, 50, 50, 0.8); }
            100% { background-color: rgba(255, 50, 50, 0.3); }
        }
        
        .king-check-bg {
            animation: checkFlash 1s infinite;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>–ü–†–û–ï–ö–¢ 1430</h1>
        <p class="subtitle">–ò–≥—Ä–∞–π—Ç–µ –≤ —à–∞—à–∫–∏ –∏ —à–∞—Ö–º–∞—Ç—ã –±–µ—Å–ø–ª–∞—Ç–Ω–æ –±–µ–∑ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∏ —Å–º—Å</p>
        
        <div id="welcomeSection" class="welcome-section">
            <div class="welcome-container">
                <div class="welcome-text">–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</div>
                <div class="welcome-subtext">–í—ã–±–µ—Ä–∏—Ç–µ –∏–≥—Ä—É –≤ –º–µ–Ω—é</div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div id="loadingScreen" class="loading">
            <div class="spinner"></div>
            <p>–ó–∞–≥—Ä—É–∑–∫–∞ –∏–≥—Ä—ã...</p>
        </div>
        
        <div id="gameScreen" class="hidden">
            <div class="main-content">
                <div id="gameSection" class="game-section">
                    <div class="game-window">
                        <button id="backToModeBtn" class="back-to-mode-btn hidden">
                            ‚Üê –í–´–ë–û–† –ò–ì–†
                        </button>
                        
                        <canvas id="gameCanvas"></canvas>
                        
                        <div id="menuOverlay" class="menu-overlay">
                            <div id="mainMenu" class="menu-content">
                                <div class="menu-header">
                                    <h2 class="menu-title">–ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ</h2>
                                    <p class="menu-subtitle">–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ</p>
                                </div>
                                
                                <div class="menu-buttons-container">
                                    <button class="menu-button" data-action="gameSelect">
                                        üéÆ –ù–ê–ß–ê–¢–¨ –ò–ì–†–£
                                    </button>
                                    <button class="menu-button" data-action="achievements">
                                        üèÜ –î–û–°–¢–ò–ñ–ï–ù–ò–Ø
                                    </button>
                                    <button class="menu-button" data-action="stats">
                                        üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê
                                    </button>
                                    <button class="menu-button" data-action="instructions">
                                        üìñ –ò–ù–°–¢–†–£–ö–¶–ò–Ø
                                    </button>
                                    <button class="menu-button" data-action="settings">
                                        ‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò
                                    </button>
                                </div>
                            </div>
                            
                            <div id="gameSelectMenu" class="menu-content hidden">
                                <div class="menu-header">
                                    <h2 class="menu-title">–í–´–ë–ï–†–ò–¢–ï –ò–ì–†–£</h2>
                                    <p class="menu-subtitle">–í–æ —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å—ã–≥—Ä–∞—Ç—å?</p>
                                </div>
                                
                                <div class="menu-buttons-container">
                                    <div class="game-select-grid">
                                        <button class="game-select-button" data-game="checkers">
                                            <div class="checkers-icon"></div>
                                            <div>–®–ê–®–ö–ò</div>
                                        </button>
                                        <button class="game-select-button" data-game="chess">
                                            <div class="game-icon">‚ôî</div>
                                            <div>–®–ê–•–ú–ê–¢–´</div>
                                        </button>
                                    </div>
                                    
                                    <button class="menu-button small" data-action="backToMain">
                                        ‚Üê –ù–ê–ó–ê–î
                                    </button>
                                </div>
                            </div>
                            
                            <div id="achievementsMenu" class="menu-content hidden">
                                <div class="menu-header">
                                    <h2 class="menu-title">–î–û–°–¢–ò–ñ–ï–ù–ò–Ø</h2>
                                    <p class="menu-subtitle">–í–∞—à –ø—Ä–æ–≥—Ä–µ—Å—Å</p>
                                </div>
                                
                                <div id="achievementsList" class="content-container">
                                </div>
                                
                                <button class="menu-button small" data-action="backToMain">
                                    ‚Üê –ù–ê–ó–ê–î
                                </button>
                            </div>
                            
                            <div id="statsMenu" class="menu-content hidden">
                                <div class="menu-header">
                                    <h2 class="menu-title">–°–¢–ê–¢–ò–°–¢–ò–ö–ê</h2>
                                    <p class="menu-subtitle">–í–∞—à–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã</p>
                                </div>
                                
                                <div id="statsList" class="content-container">
                                </div>
                                
                                <button class="menu-button small" data-action="backToMain">
                                    ‚Üê –ù–ê–ó–ê–î
                                </button>
                            </div>
                            
                            <div id="instructionsMenu" class="menu-content hidden">
                                <div class="menu-header">
                                    <h2 class="menu-title">–ò–ù–°–¢–†–£–ö–¶–ò–Ø</h2>
                                    <p class="menu-subtitle">–ö–∞–∫ –∏–≥—Ä–∞—Ç—å</p>
                                </div>
                                
                                <div class="content-container">
                                    <div class="instructions-content">
                                        <h3>–®–ê–®–ö–ò</h3>
                                        <ul>
                                            <li>–ò–≥—Ä–æ–∫ –≤—Å–µ–≥–¥–∞ —Å–Ω–∏–∑—É, –ò–ò –≤—Å–µ–≥–¥–∞ —Å–≤–µ—Ä—Ö—É</li>
                                            <li>–ë–µ–ª—ã–µ —Ö–æ–¥—è—Ç –ø–µ—Ä–≤—ã–º–∏</li>
                                            <li>–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ —Å–≤–æ—é —à–∞—à–∫—É</li>
                                            <li>–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –≥–æ–ª—É–±–æ–π –∫—Ä—É–∂–æ–∫ –¥–ª—è —Ö–æ–¥–∞</li>
                                            <li>–û–±—ã—á–Ω—ã–π —Ö–æ–¥ - –≤–ø–µ—Ä–µ–¥ –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏</li>
                                            <li>–í–∑—è—Ç–∏–µ - —á–µ—Ä–µ–∑ –≤—Ä–∞–∂–µ—Å–∫—É—é —à–∞—à–∫—É</li>
                                            <li>–î–æ–π–¥—è –¥–æ –∫—Ä–∞—é, —à–∞—à–∫–∞ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –¥–∞–º–∫–æ–π</li>
                                            <li>–î–∞–º–∫–∞ —Ö–æ–¥–∏—Ç –Ω–∞ –ª—é–±–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ</li>
                                            <li>–ö–æ—Ä–æ–ª—è —Å—ä–µ—Å—Ç—å –Ω–µ–ª—å–∑—è</li>
                                        </ul>
                                    </div>
                                    
                                    <div class="instructions-content">
                                        <h3>–®–ê–•–ú–ê–¢–´</h3>
                                        <ul>
                                            <li>–ò–≥—Ä–æ–∫ –≤—Å–µ–≥–¥–∞ —Å–Ω–∏–∑—É, –ò–ò –≤—Å–µ–≥–¥–∞ —Å–≤–µ—Ä—Ö—É</li>
                                            <li>–ë–µ–ª—ã–µ —Ö–æ–¥—è—Ç –ø–µ—Ä–≤—ã–º–∏</li>
                                            <li>–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ —Å–≤–æ—é —Ñ–∏–≥—É—Ä—É</li>
                                            <li>–ì–æ–ª—É–±—ã–µ —Ç–æ—á–∫–∏ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ö–æ–¥—ã</li>
                                            <li>–®–ê–• - –∫–æ–≥–¥–∞ –∫–æ—Ä–æ–ª—å –ø–æ–¥ —É–¥–∞—Ä–æ–º (–ø–æ–ª–µ –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ—Ç—Å—è –∫—Ä–∞—Å–Ω—ã–º)</li>
                                            <li>–ü—Ä–∏ –®–ê–•–µ –Ω—É–∂–Ω–æ —É–≤–µ—Å—Ç–∏ –∫–æ—Ä–æ–ª—è –∏–∑-–ø–æ–¥ —É–¥–∞—Ä–∞</li>
                                            <li>–ú–ê–¢ - –∫–æ–≥–¥–∞ –∫–æ—Ä–æ–ª—å –ø–æ–¥ —É–¥–∞—Ä–æ–º –∏ –Ω–µ–∫—É–¥–∞ —Ö–æ–¥–∏—Ç—å</li>
                                            <li>–¶–µ–ª—å - –ø–æ—Å—Ç–∞–≤–∏—Ç—å –º–∞—Ç –∫–æ—Ä–æ–ª—é –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞</li>
                                            <li>–ö–æ—Ä–æ–ª—è —Å—ä–µ—Å—Ç—å –Ω–µ–ª—å–∑—è</li>
                                            <li>–ü–µ—à–∫–∞ –ø—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ –∫—Ä–∞—è –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ –¥—Ä—É–≥—É—é —Ñ–∏–≥—É—Ä—É</li>
                                            <li>–ù–ò–ß–¨–Ø - –∫–æ–≥–¥–∞ –Ω–∞ –¥–æ—Å–∫–µ –æ—Å—Ç–∞–ª–∏—Å—å —Ç–æ–ª—å–∫–æ –¥–≤–∞ –∫–æ—Ä–æ–ª—è</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <button class="menu-button small" data-action="backToMain">
                                    ‚Üê –ù–ê–ó–ê–î
                                </button>
                            </div>
                            
                            <div id="settingsMenu" class="menu-content hidden">
                                <div class="menu-header">
                                    <h2 class="menu-title">–ù–ê–°–¢–†–û–ô–ö–ò</h2>
                                    <p class="menu-subtitle">–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –∏–≥—Ä—É</p>
                                </div>
                                
                                <div class="content-container">
                                    <div class="setting-item setting-item-with-volume">
                                        <div class="setting-label">
                                            <i>üéµ</i> –ú—É–∑—ã–∫–∞
                                        </div>
                                        <div style="margin-top:6px; font-size:1.05rem; opacity:0.9;">–¢—Ä–µ–∫: <b>Static on the Radio</b></div>
                                        <div class="volume-controls">
                                            <label class="setting-toggle">
                                                <input type="checkbox" id="musicToggle" checked>
                                                <span class="setting-slider"></span>
                                            </label>
                                            <div class="volume-slider-container">
                                                <input type="range" min="0" max="100" value="50" class="volume-slider" id="musicVolume">
                                                <div class="volume-value" id="musicVolumeValue">50%</div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="setting-item setting-item-with-volume">
                                        <div class="setting-label">
                                            <i>üîä</i> –ó–≤—É–∫–∏
                                        </div>
                                        <div class="volume-controls">
                                            <label class="setting-toggle">
                                                <input type="checkbox" id="soundToggle" checked>
                                                <span class="setting-slider"></span>
                                            </label>
                                            <div class="volume-slider-container">
                                                <input type="range" min="0" max="100" value="70" class="volume-slider" id="soundVolume">
                                                <div class="volume-value" id="soundVolumeValue">70%</div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="setting-item setting-item-with-volume">
                                        <div class="setting-label">
                                            <i>üîî</i> –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
                                        </div>
                                        <div class="volume-controls">
                                            <label class="setting-toggle">
                                                <input type="checkbox" id="notificationToggle" checked>
                                                <span class="setting-slider"></span>
                                            </label>
                                            <div class="volume-slider-container">
                                                <input type="range" min="0" max="100" value="60" class="volume-slider" id="notificationVolume">
                                                <div class="volume-value" id="notificationVolumeValue">60%</div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="setting-item">
                                        <div class="setting-label">
                                            <i>‚öîÔ∏è</i> –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –≤–∑—è—Ç–∏–µ (—à–∞—à–∫–∏)
                                        </div>
                                        <div class="volume-controls">
                                            <label class="setting-toggle">
                                                <input type="checkbox" id="mandatoryCaptureToggle" checked>
                                                <span class="setting-slider"></span>
                                            </label>
                                            <div class="volume-slider-container">
                                                <div class="volume-value" id="mandatoryCaptureValue">–í–ö–õ</div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <button class="menu-button" data-action="resetProgress" style="background: linear-gradient(135deg, rgba(255, 65, 108, 0.45) 0%, rgba(255, 75, 43, 0.35) 100%); border-color: rgba(255, 65, 108, 0.7); margin-top: 20px;">
                                        üîÑ –°–ë–†–û–°–ò–¢–¨ –ü–†–û–ì–†–ï–°–°
                                    </button>
                                </div>
                                
                                <button class="menu-button small" data-action="backToMain">
                                    ‚Üê –ù–ê–ó–ê–î
                                </button>
                            </div>
                        </div>
                        
                        <div id="promotionOverlay" class="promotion-overlay hidden">
                            <div class="promotion-content">
                                <div class="promotion-title">–í–´–ë–ï–†–ò–¢–ï –§–ò–ì–£–†–£ –î–õ–Ø –ü–†–ï–í–†–ê–©–ï–ù–ò–Ø –ü–ï–®–ö–ò</div>
                                <div class="promotion-grid">
                                    <button class="promotion-button" data-piece="q">
                                        <div class="promotion-icon">‚ôï</div>
                                        <div>–§–ï–†–ó–¨</div>
                                    </button>
                                    <button class="promotion-button" data-piece="r">
                                        <div class="promotion-icon">‚ôñ</div>
                                        <div>–õ–ê–î–¨–Ø</div>
                                    </button>
                                    <button class="promotion-button" data-piece="b">
                                        <div class="promotion-icon">‚ôó</div>
                                        <div>–°–õ–û–ù</div>
                                    </button>
                                    <button class="promotion-button" data-piece="n">
                                        <div class="promotion-icon">‚ôò</div>
                                        <div>–ö–û–ù–¨</div>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="game-info">
                        <button id="restartBtn" class="action-button red hidden">
                            üîÑ –ù–û–í–ê–Ø –ò–ì–†–ê
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="notificationContainer"></div>
    
    <audio id="backgroundMusic" loop>
        <source src="01 - Static on the Radio.mp3" type="audio/mpeg">
        –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∞—É–¥–∏–æ —ç–ª–µ–º–µ–Ω—Ç.
    </audio>
    
    <script>
        let canvasWidth = 700;
        let canvasHeight = 700;
        let BOARD_SIZE = 550;
        let CELL_SIZE = BOARD_SIZE / 8;
        let scale = 1;
        
        const BLACK = [26, 26, 46];
        const BLUE = [15, 52, 96];
        const LIGHT_BLUE = [0, 114, 255];
        const WHITE = [255, 255, 255];
        const GRAY = [200, 200, 200];
        const DARK_GRAY = [100, 100, 100];
        const GREEN = [46, 204, 113];
        const PURPLE = [155, 89, 182];
        const YELLOW = [241, 196, 15];
        const RED = [231, 76, 60];
        const BOARD_LIGHT = [240, 217, 181];
        const BOARD_DARK = [181, 136, 99];
        const SELECT_COLOR = [0, 200, 0];
        const MOVE_COLOR = [0, 150, 255, 150];
        const CAPTURE_COLOR = [255, 100, 100, 200];
        const CHECK_COLOR = [255, 50, 50, 200];
        const CAPTURE_HIGHLIGHT = [255, 100, 100, 150];
        const KING_CHECK_COLOR = [255, 0, 0, 200];
        
        const achievements = {
            'welcome': {name: '–ü—Ä–∏–≤–µ—Ç', desc: '–ó–∞–π—Ç–∏ –≤ –∏–≥—Ä—É', rarity: 'common', progress: 0, max: 1, unlocked: false, icon: 'üëã'},
            'genius': {name: '–ì–µ–Ω–∏–π', desc: '–ó–∞–π—Ç–∏ –≤ —Ä–∞—É–Ω–¥', rarity: 'common', progress: 0, max: 1, unlocked: false, icon: 'üß†'},
            'musician': {name: '–ú—É–∑—ã–∫–∞–Ω—Ç', desc: '–í—ã–∫–ª—é—á–∏—Ç—å –∏ –≤–∫–ª—é—á–∏—Ç—å –º—É–∑—ã–∫—É', rarity: 'common', progress: 0, max: 1, unlocked: false, icon: 'üéµ'},
            'winner': {name: '–ü–æ–±–µ–¥–∏—Ç–µ–ª—å', desc: '–ü–æ–±–µ–¥–∏—Ç—å –≤ —Ä–∞—É–Ω–¥', rarity: 'rare', progress: 0, max: 1, unlocked: false, icon: 'üèÖ'},
            'absolute-winner': {name: '–ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø–æ–±–µ–¥–∏—Ç–µ–ª—å', desc: '–ü–æ–±–µ–¥–∏—Ç—å 10 —Ä–∞–∑ –ø–æ–¥—Ä—è–¥', rarity: 'rare', progress: 0, max: 10, unlocked: false, icon: 'üëë'},
            'hurry-up': {name: '–ü–æ—Å–ø–µ—à–∏—à—å - –ò–ò —Ä–∞—Å—Å–º–µ—à–∏—à—å', desc: '–ü—Ä–æ–∏–≥—Ä–∞—Ç—å —É –ò–ò', rarity: 'rare', progress: 0, max: 1, unlocked: false, icon: 'üòÇ'},
            'definitely-winner': {name: '–ù—É —Ç–æ—á–Ω–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª—å', desc: '–ü–æ–±–µ–¥–∏—Ç—å 20 —Ä–∞–∑ –ø–æ–¥—Ä—è–¥', rarity: 'epic', progress: 0, max: 20, unlocked: false, icon: '‚≠ê'},
            'talentless': {name: '–ë–µ–∑–¥–∞—Ä—å x2', desc: '–ü—Ä–æ–∏–≥—Ä–∞—Ç—å 10 —Ä–∞–∑ –ø–æ–¥—Ä—è–¥', rarity: 'epic', progress: 0, max: 10, unlocked: false, icon: 'üí©'},
            'king-of-kings': {name: '–¶–∞—Ä—å —Ü–∞—Ä–µ–π', desc: '–ü–æ–±–µ–¥–∏—Ç—å –ò–ò 100 —Ä–∞–∑ –ø–æ–¥—Ä—è–¥', rarity: 'legendary', progress: 0, max: 100, unlocked: false, icon: 'üëëüëë'},
            'tasty': {name: '–í–∫—É—Å–Ω–æ', desc: '–°—ä–µ—Å—Ç—å 30 —à–∞—à–µ–∫ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞', rarity: 'legendary', progress: 0, max: 30, unlocked: false, icon: 'üòã'},
            'all-achievements': {name: '–í—Å–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è', desc: '–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è', rarity: 'mythic', progress: 0, max: 10, unlocked: false, icon: 'üåà'}
        };
        
        const playerStats = {
            games_played: 0,
            wins: 0,
            losses: 0,
            draws: 0,
            consecutive_wins: 0,
            consecutive_losses: 0,
            eaten_kings: 0,
            music_toggles: 0,
            eaten_checkers: 0,
            kings_made: 0,
            chess_games: 0,
            pawn_promotions: 0
        };
        
        const SCREENS = {
            menu: 0,
            checkers: 1,
            chess: 2
        };
        
        let currentScreen = SCREENS.menu;
        let showMenu = true;
        let activeMenu = 'main';

        // –ò–ì–†–ê–ß–ö –í–°–ï–ì–î–ê –ò–ì–†–ê–ï–¢ –ë–ï–õ–´–ú–ò –°–ù–ò–ó–£
        let playerColor = 'white';
        let aiColor = 'black';
        let playerIsWhite = true;
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —à–∞—à–µ–∫
        let mandatoryCapture = true;
        
        // –®–∞—à–∫–∏
        let checkersBoard = [];
        let currentCheckersPlayer = 'white';
        let selectedChecker = null;
        let possibleMoves = [];
        let mustCapture = false;
        let checkersGameOver = false;
        let checkersWinner = null;
        let moveInProgress = false;
        
        // –®–∞—Ö–º–∞—Ç—ã
        let chessBoard = [];
        let currentChessPlayer = 'white';
        let selectedChessPiece = null;
        let chessPossibleMoves = [];
        let chessGameOver = false;
        let chessWinner = null;
        let isCheck = false;
        let checkKingPos = null;
        let chessCaptureTargets = [];
        let waitingForPromotion = false;
        let promotionPawn = null;
        let promotionColor = null;
        let kingCheckAnimation = false;
        let kingCheckAnimationFrame = 0;
        let kingCheckPosition = null;
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ —à–∞—Ö–µ –∏ –º–∞—Ç–µ
        let checkmateNotification = null;
        let checkNotification = null;
        let notificationTimer = null;
        
        // –ê—É–¥–∏–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let backgroundMusic = null;
        let audioInitialized = false;
        
        const chessPieces = {
            'p': {name: 'pawn', symbol: '‚ôô', value: 1},
            'r': {name: 'rook', symbol: '‚ôñ', value: 5},
            'n': {name: 'knight', symbol: '‚ôò', value: 3},
            'b': {name: 'bishop', symbol: '‚ôó', value: 3},
            'q': {name: 'queen', symbol: '‚ôï', value: 9},
            'k': {name: 'king', symbol: '‚ôî', value: 1000}
        };
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingScreen = document.getElementById('loadingScreen');
        const gameScreen = document.getElementById('gameScreen');
        const restartBtn = document.getElementById('restartBtn');
        const notificationContainer = document.getElementById('notificationContainer');
        const welcomeSection = document.getElementById('welcomeSection');
        const welcomeContainer = document.querySelector('.welcome-container');
        const welcomeText = welcomeSection.querySelector('.welcome-text');
        const welcomeSubtext = welcomeSection.querySelector('.welcome-subtext');
        
        const menuOverlay = document.getElementById('menuOverlay');
        const mainMenu = document.getElementById('mainMenu');
        const gameSelectMenu = document.getElementById('gameSelectMenu');
        const achievementsMenu = document.getElementById('achievementsMenu');
        const statsMenu = document.getElementById('statsMenu');
        const instructionsMenu = document.getElementById('instructionsMenu');
        const settingsMenu = document.getElementById('settingsMenu');
        const achievementsList = document.getElementById('achievementsList');
        const statsList = document.getElementById('statsList');
        const backToModeBtn = document.getElementById('backToModeBtn');
        const promotionOverlay = document.getElementById('promotionOverlay');
        const promotionButtons = document.querySelectorAll('.promotion-button');
        
        const backgroundMusicElement = document.getElementById('backgroundMusic');
        
        let audioSettings = {
            musicEnabled: true,
            musicVolume: 0.5,
            soundEnabled: true,
            soundVolume: 0.7,
            notificationEnabled: true,
            notificationVolume: 0.6,
            mandatoryCapture: true
        };
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∏—á—å–∏ (—Ç–æ–ª—å–∫–æ –¥–≤–∞ –∫–æ—Ä–æ–ª—è –Ω–∞ –¥–æ—Å–∫–µ)
        function checkKingsOnlyDraw() {
            let pieceCount = 0;
            let whiteKingFound = false;
            let blackKingFound = false;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = chessBoard[row][col];
                    if (piece) {
                        pieceCount++;
                        if (piece.type === 'k') {
                            if (piece.color === 'white') {
                                whiteKingFound = true;
                            } else {
                                blackKingFound = true;
                            }
                        }
                    }
                }
            }
            
            // –ï—Å–ª–∏ –Ω–∞ –¥–æ—Å–∫–µ —Ç–æ–ª—å–∫–æ –¥–≤–∞ –∫–æ—Ä–æ–ª—è - –Ω–∏—á—å—è
            return pieceCount === 2 && whiteKingFound && blackKingFound;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∏—á—å–∏ (–Ω–µ—Ç –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤ —É –æ–±–æ–∏—Ö –∏–≥—Ä–æ–∫–æ–≤)
        function checkStalemateDraw() {
            const whiteHasMoves = hasAnyValidMove('white');
            const blackHasMoves = hasAnyValidMove('black');
            
            return !whiteHasMoves && !blackHasMoves && !isCheck;
        }
        
        function showCheckmateNotification(winner) {
            // –£–±–∏—Ä–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            if (checkmateNotification) {
                document.body.removeChild(checkmateNotification);
            }
            if (checkNotification) {
                document.body.removeChild(checkNotification);
                checkNotification = null;
            }
            if (notificationTimer) {
                clearTimeout(notificationTimer);
            }
            
            // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –º–∞—Ç–µ
            checkmateNotification = document.createElement('div');
            checkmateNotification.className = 'checkmate-notification';
            const winnerText = winner === 'white' ? '–ë–ï–õ–´–ï (–ò–ì–†–û–ö)' : '–ß–ï–†–ù–´–ï (–ò–ò)';
            checkmateNotification.innerHTML = `
                <h3>–®–ê–• –ò –ú–ê–¢!</h3>
                <p>–ü–û–ë–ï–î–ò–õ–ò: ${winnerText}</p>
            `;
            document.body.appendChild(checkmateNotification);
            
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–±–∏—Ä–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥
            notificationTimer = setTimeout(() => {
                if (checkmateNotification && document.body.contains(checkmateNotification)) {
                    checkmateNotification.style.animation = 'popOut 0.5s ease forwards';
                    setTimeout(() => {
                        if (checkmateNotification && document.body.contains(checkmateNotification)) {
                            document.body.removeChild(checkmateNotification);
                            checkmateNotification = null;
                        }
                    }, 500);
                }
            }, 5000);
        }
        
        function showCheckNotification(isForPlayer = true) {
            // –£–±–∏—Ä–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            if (checkNotification) {
                document.body.removeChild(checkNotification);
                checkNotification = null;
            }
            if (notificationTimer) {
                clearTimeout(notificationTimer);
            }
            
            // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —à–∞—Ö–µ
            checkNotification = document.createElement('div');
            checkNotification.className = 'check-notification';
            const targetText = isForPlayer ? '–í–ê–® –ö–û–†–û–õ–¨ –ü–û–î –®–ê–•–û–ú!' : '–®–ê–• –ö–û–†–û–õ–Æ –ü–†–û–¢–ò–í–ù–ò–ö–ê!';
            checkNotification.innerHTML = `
                <h3>–®–ê–•!</h3>
                <p>${targetText}</p>
            `;
            document.body.appendChild(checkNotification);
            
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–±–∏—Ä–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
            notificationTimer = setTimeout(() => {
                if (checkNotification && document.body.contains(checkNotification)) {
                    checkNotification.style.animation = 'popOut 0.5s ease forwards';
                    setTimeout(() => {
                        if (checkNotification && document.body.contains(checkNotification)) {
                            document.body.removeChild(checkNotification);
                            checkNotification = null;
                        }
                    }, 500);
                }
            }, 3000);
        }
        
        function initAudio() {
            if (audioInitialized) return;
            
            try {
                const musicUrl = '01 - Static on the Radio.mp3';
                backgroundMusicElement.src = musicUrl;
                
                updateAudioVolumes();
                
                if (audioSettings.musicEnabled) {
                    const playPromise = backgroundMusicElement.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.catch(e => {
                            console.log("–ê–≤—Ç–æ–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ –±—Ä–∞—É–∑–µ—Ä–æ–º, –Ω–æ –º—É–∑—ã–∫–∞ –≥–æ—Ç–æ–≤–∞");
                        });
                    }
                }
                
                audioInitialized = true;
                console.log("–ê—É–¥–∏–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ —Å –º—É–∑—ã–∫–æ–π –∏–∑ —É–∫–∞–∑–∞–Ω–Ω–æ–π —Å—Å—ã–ª–∫–∏ Vocaroo");
                
                backgroundMusicElement.addEventListener('error', function(e) {
                    console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º—É–∑—ã–∫–∏:", e);
                });
                
                backgroundMusicElement.addEventListener('canplaythrough', function() {
                    console.log("–ú—É–∑—ã–∫–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏ –≥–æ—Ç–æ–≤–∞ –∫ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—é");
                });
                
            } catch (error) {
                console.error("–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∞—É–¥–∏–æ:", error);
            }
        }
        
        function updateAudioVolumes() {
            backgroundMusicElement.volume = audioSettings.musicEnabled ? audioSettings.musicVolume : 0;
            
            document.getElementById('musicVolume').value = audioSettings.musicVolume * 100;
            document.getElementById('musicVolumeValue').textContent = Math.round(audioSettings.musicVolume * 100) + '%';
            document.getElementById('musicToggle').checked = audioSettings.musicEnabled;
            
            document.getElementById('soundVolume').value = audioSettings.soundVolume * 100;
            document.getElementById('soundVolumeValue').textContent = Math.round(audioSettings.soundVolume * 100) + '%';
            document.getElementById('soundToggle').checked = audioSettings.soundEnabled;
            
            document.getElementById('notificationVolume').value = audioSettings.notificationVolume * 100;
            document.getElementById('notificationVolumeValue').textContent = Math.round(audioSettings.notificationVolume * 100) + '%';
            document.getElementById('notificationToggle').checked = audioSettings.notificationEnabled;
            
            document.getElementById('mandatoryCaptureToggle').checked = audioSettings.mandatoryCapture;
            document.getElementById('mandatoryCaptureValue').textContent = audioSettings.mandatoryCapture ? '–í–ö–õ' : '–í–´–ö–õ';
            mandatoryCapture = audioSettings.mandatoryCapture;
            
            saveAudioSettings();
        }
        
        function saveAudioSettings() {
            try {
                localStorage.setItem('project1430_audio_settings', JSON.stringify(audioSettings));
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∞—É–¥–∏–æ:', e);
            }
        }
        
        function loadAudioSettings() {
            try {
                const saved = localStorage.getItem('project1430_audio_settings');
                if (saved) {
                    const data = JSON.parse(saved);
                    Object.assign(audioSettings, data);
                }
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∞—É–¥–∏–æ:', e);
            }
        }
        
        function toggleMusic(enabled) {
            audioSettings.musicEnabled = enabled;
            if (enabled) {
                backgroundMusicElement.volume = audioSettings.musicVolume;
                backgroundMusicElement.play().catch(e => {
                    console.log("–ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –º—É–∑—ã–∫—É:", e);
                });
            } else {
                backgroundMusicElement.pause();
            }
            updateAudioVolumes();
        }
        
        function updateWelcomeMessage(text, subtext = '') {
            welcomeText.textContent = text;
            welcomeSubtext.textContent = subtext;
        }
        
        function showAchievementNotification(achievement) {
            if (!audioSettings.notificationEnabled) return;
            
            const notificationEl = document.createElement('div');
            notificationEl.className = `achievement-notification rarity-${achievement.rarity}`;
            
            notificationEl.innerHTML = `
                <div class="achievement-notification-icon">${achievement.icon}</div>
                <div class="achievement-notification-content">
                    <div class="achievement-notification-title">${achievement.name}</div>
                    <div class="achievement-notification-desc">${achievement.desc}</div>
                </div>
            `;
            
            notificationContainer.appendChild(notificationEl);
            
            setTimeout(() => {
                if (notificationContainer.contains(notificationEl)) {
                    notificationContainer.removeChild(notificationEl);
                }
            }, 5000);
            
            if (audioSettings.soundEnabled) {
                playAchievementSound();
            }
        }
        
        function playAchievementSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2);
                oscillator.frequency.setValueAtTime(1046.50, audioContext.currentTime + 0.3);
                
                gainNode.gain.setValueAtTime(audioSettings.soundVolume * 0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                console.log("–ê—É–¥–∏–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ");
            }
        }
        
        function showNotification(title, message) {
            const notificationEl = document.createElement('div');
            notificationEl.className = 'notification';
            notificationEl.innerHTML = `
                <h4>${title}</h4>
                <p>${message}</p>
            `;
            
            notificationContainer.appendChild(notificationEl);
            
            setTimeout(() => {
                if (notificationContainer.contains(notificationEl)) {
                    notificationContainer.removeChild(notificationEl);
                }
            }, 3000);
        }
        
        function updateAchievement(achievementId, progress = 1) {
            if (achievements[achievementId]) {
                const achievement = achievements[achievementId];
                if (!achievement.unlocked) {
                    achievement.progress += progress;
                    if (achievement.progress > achievement.max) {
                        achievement.progress = achievement.max;
                    }
                    
                    if (achievement.progress >= achievement.max) {
                        achievement.unlocked = true;
                        showAchievementNotification(achievement);
                        checkAllAchievements();
                        
                        if (activeMenu === 'achievements') {
                            updateAchievementsList();
                        }
                    }
                    
                    saveProgress();
                }
            }
        }
        
        function checkAllAchievements() {
            let unlockedCount = 0;
            for (const key in achievements) {
                if (key !== 'all-achievements' && achievements[key].unlocked) {
                    unlockedCount++;
                }
            }
            
            achievements['all-achievements'].progress = unlockedCount;
            if (unlockedCount >= achievements['all-achievements'].max) {
                achievements['all-achievements'].unlocked = true;
                showAchievementNotification(achievements['all-achievements']);
            }
        }
        
        function saveProgress() {
            const data = {
                achievements,
                playerStats
            };
            try {
                localStorage.setItem('project1430_save', JSON.stringify(data));
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:', e);
            }
        }
        
        function loadProgress() {
            try {
                const saved = localStorage.getItem('project1430_save');
                if (saved) {
                    const data = JSON.parse(saved);
                    Object.assign(achievements, data.achievements);
                    Object.assign(playerStats, data.playerStats);
                }
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:', e);
            }
        }
        
        function showMenuScreen(menuType = 'main') {
            showMenu = true;
            activeMenu = menuType;
            menuOverlay.classList.remove('hidden');
            
            mainMenu.classList.add('hidden');
            gameSelectMenu.classList.add('hidden');
            achievementsMenu.classList.add('hidden');
            statsMenu.classList.add('hidden');
            instructionsMenu.classList.add('hidden');
            settingsMenu.classList.add('hidden');
            
            switch(menuType) {
                case 'main':
                    mainMenu.classList.remove('hidden');
                    break;
                case 'gameSelect':
                    gameSelectMenu.classList.remove('hidden');
                    break;
                case 'achievements':
                    updateAchievementsList();
                    achievementsMenu.classList.remove('hidden');
                    break;
                case 'stats':
                    updateStatsList();
                    statsMenu.classList.remove('hidden');
                    break;
                case 'instructions':
                    instructionsMenu.classList.remove('hidden');
                    break;
                case 'settings':
                    settingsMenu.classList.remove('hidden');
                    break;
            }
        }
        
        function hideMenu() {
            showMenu = false;
            menuOverlay.classList.add('hidden');
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ —Ç–µ–∫—É—â–µ–º –¥–µ–π—Å—Ç–≤–∏–∏
            if (currentScreen === SCREENS.checkers && !checkersGameOver) {
                if (currentCheckersPlayer === playerColor) {
                    updateWelcomeMessage("–í–∞—à —Ö–æ–¥ (–±–µ–ª—ã–µ)", "–í—ã–±–µ—Ä–∏—Ç–µ —à–∞—à–∫—É");
                } else {
                    updateWelcomeMessage("–•–æ–¥ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ (—á–µ—Ä–Ω—ã–µ)", "–ü–æ–¥–æ–∂–¥–∏—Ç–µ...");
                }
            } else if (currentScreen === SCREENS.chess && !chessGameOver) {
                if (currentChessPlayer === playerColor) {
                    updateWelcomeMessage("–í–∞—à —Ö–æ–¥ (–±–µ–ª—ã–µ)", "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É");
                } else {
                    updateWelcomeMessage("–•–æ–¥ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ (—á–µ—Ä–Ω—ã–µ)", "–ü–æ–¥–æ–∂–¥–∏—Ç–µ...");
                }
            } else {
                updateWelcomeMessage("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!", "–í—ã–±–µ—Ä–∏—Ç–µ –∏–≥—Ä—É –≤ –º–µ–Ω—é");
            }
        }
        
        function updateAchievementsList() {
            achievementsList.innerHTML = '';
            
            for (const key in achievements) {
                const achievement = achievements[key];
                const achievementEl = document.createElement('div');
                achievementEl.className = `achievement-item ${achievement.unlocked ? 'unlocked' : ''}`;
                
                const progressPercent = Math.round((achievement.progress / achievement.max) * 100);
                
                achievementEl.innerHTML = `
                    <div>
                        <span class="achievement-icon">${achievement.icon}</span>
                        <div class="achievement-name">${achievement.name}</div>
                        <div class="achievement-desc">${achievement.desc}</div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progressPercent}%"></div>
                        </div>
                        <div class="progress-text">${achievement.progress}/${achievement.max} (${progressPercent}%)</div>
                    </div>
                `;
                
                achievementsList.appendChild(achievementEl);
            }
        }
        
        function updateStatsList() {
            statsList.innerHTML = '';
            
            const statsData = [
                {label: '–í—Å–µ–≥–æ –∏–≥—Ä —Å—ã–≥—Ä–∞–Ω–æ', value: playerStats.games_played},
                {label: '–ü–æ–±–µ–¥', value: playerStats.wins},
                {label: '–ü–æ—Ä–∞–∂–µ–Ω–∏–π', value: playerStats.losses},
                {label: '–ù–∏—á—å–∏—Ö', value: playerStats.draws},
                {label: '–¢–µ–∫—É—â–∞—è —Å–µ—Ä–∏—è –ø–æ–±–µ–¥', value: playerStats.consecutive_wins},
                {label: '–¢–µ–∫—É—â–∞—è —Å–µ—Ä–∏—è –ø–æ—Ä–∞–∂–µ–Ω–∏–π', value: playerStats.consecutive_losses},
                {label: '–°—ä–µ–¥–µ–Ω–æ —à–∞—à–µ–∫', value: playerStats.eaten_checkers},
                {label: '–°–¥–µ–ª–∞–Ω–æ –¥–∞–º–æ–∫', value: playerStats.kings_made},
                {label: '–ò–≥—Ä –≤ —à–∞—Ö–º–∞—Ç—ã', value: playerStats.chess_games},
                {label: '–°—ä–µ–¥–µ–Ω–æ –∫–æ—Ä–æ–ª–µ–π', value: playerStats.eaten_kings},
                {label: '–ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–π –ø–µ—à–µ–∫', value: playerStats.pawn_promotions},
                {label: '–î–æ—Å—Ç–∏–∂–µ–Ω–∏–π —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ', value: Object.values(achievements).filter(a => a.unlocked).length + ' –∏–∑ 11'}
            ];
            
            statsData.forEach(stat => {
                const statEl = document.createElement('div');
                statEl.className = 'stat-item';
                statEl.innerHTML = `
                    <div class="stat-name">${stat.label}</div>
                    <div class="stat-value">${stat.value}</div>
                `;
                statsList.appendChild(statEl);
            });
        }
        
        function drawMenuScreen() {
            clearCanvas();
            
            ctx.fillStyle = `rgb(${BLACK.join(',')})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            return SCREENS.menu;
        }
        
        function initCheckers() {
            checkersBoard = Array(8).fill().map(() => Array(8).fill(null));
            
            playerColor = 'white';
            aiColor = 'black';
            playerIsWhite = true;
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 8; col++) {
                    if ((row + col) % 2 === 1) {
                        checkersBoard[row][col] = {type: 'checker', color: 'black', isKing: false};
                    }
                }
            }
            
            for (let row = 5; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if ((row + col) % 2 === 1) {
                        checkersBoard[row][col] = {type: 'checker', color: 'white', isKing: false};
                    }
                }
            }
            
            currentCheckersPlayer = 'white';
            selectedChecker = null;
            possibleMoves = [];
            mustCapture = false;
            checkersGameOver = false;
            checkersWinner = null;
            moveInProgress = false;
            
            restartBtn.classList.remove('hidden');
            backToModeBtn.classList.remove('hidden');
            hideMenu();
            
            updateWelcomeMessage("–í–∞—à —Ö–æ–¥ (–±–µ–ª—ã–µ)", "–í—ã–±–µ—Ä–∏—Ç–µ —à–∞—à–∫—É");
        }
        
        function drawCheckersScreen() {
            clearCanvas();
            
            ctx.fillStyle = `rgb(${WHITE.join(',')})`;
            const titleSize = Math.min(canvas.width * 0.05, 28);
            ctx.font = `bold ${titleSize}px Arial`;
            ctx.textAlign = 'center';
            
            // –í–ï–†–ù–£–õ: –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∏–≥—Ä—ã (—á–µ–π —Ö–æ–¥)
            if (checkersGameOver) {
                const winnerText = checkersWinner === 'white' ? '–ë–ï–õ–´–ï (–ò–ì–†–û–ö)' : '–ß–ï–†–ù–´–ï (–ò–ò)';
                const gameOverText = `–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê! –ü–û–ë–ï–î–ò–õ–ò: ${winnerText}`;
                
                const maxWidth = canvas.width * 0.9;
                const textWidth = ctx.measureText(gameOverText).width;
                
                if (textWidth > maxWidth) {
                    const parts = gameOverText.split(': ');
                    if (parts.length > 1) {
                        ctx.fillText(parts[0] + ':', canvas.width / 2, 60 * scale);
                        ctx.fillText(parts[1], canvas.width / 2, 90 * scale);
                    } else {
                        ctx.fillText(gameOverText.substring(0, Math.floor(gameOverText.length * 0.8)) + '...', 
                                    canvas.width / 2, 70 * scale);
                    }
                } else {
                    ctx.fillText(gameOverText, canvas.width / 2, 70 * scale);
                }
            } else {
                const status = currentCheckersPlayer === playerColor ? "–í–ê–® –•–û–î (–ë–ï–õ–´–ï)" : "–•–û–î –ö–û–ú–ü–¨–Æ–¢–ï–†–ê (–ß–ï–†–ù–´–ï)";
                const maxWidth = canvas.width * 0.9;
                const textWidth = ctx.measureText(status).width;
                
                if (textWidth > maxWidth) {
                    const smallerSize = Math.min(canvas.width * 0.04, 22);
                    ctx.font = `bold ${smallerSize}px Arial`;
                    ctx.fillText(status, canvas.width / 2, 70 * scale);
                    ctx.font = `bold ${titleSize}px Arial`;
                } else {
                    ctx.fillText(status, canvas.width / 2, 70 * scale);
                }
            }
            
            const boardX = (canvas.width - BOARD_SIZE * scale) / 2;
            const boardY = 130 * scale;
            
            ctx.fillStyle = 'rgb(44, 62, 80)';
            ctx.fillRect(boardX - 12 * scale, boardY - 12 * scale, 
                BOARD_SIZE * scale + 24 * scale, BOARD_SIZE * scale + 24 * scale);
            
            drawCheckersBoard(boardX, boardY);
            
            return SCREENS.checkers;
        }
        
        function drawCheckersBoard(x, y) {
            const scaledCellSize = CELL_SIZE * scale;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cellColor = (row + col) % 2 === 0 ? BOARD_LIGHT : BOARD_DARK;
                    ctx.fillStyle = `rgb(${cellColor.join(',')})`;
                    ctx.fillRect(
                        x + col * scaledCellSize,
                        y + row * scaledCellSize,
                        scaledCellSize,
                        scaledCellSize
                    );
                }
            }
            
            if (selectedChecker) {
                for (const move of possibleMoves) {
                    const [toRow, toCol, isCapture, capturedRow, capturedCol] = move;
                    const centerX = x + toCol * scaledCellSize + scaledCellSize / 2;
                    const centerY = y + toRow * scaledCellSize + scaledCellSize / 2;
                    const radius = scaledCellSize / 3.2;
                    
                    ctx.fillStyle = isCapture ? 
                        `rgba(${CAPTURE_COLOR[0]}, ${CAPTURE_COLOR[1]}, ${CAPTURE_COLOR[2]}, 0.7)` :
                        `rgba(${MOVE_COLOR[0]}, ${MOVE_COLOR[1]}, ${MOVE_COLOR[2]}, 0.7)`;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (isCapture) {
                        ctx.strokeStyle = `rgb(${RED.join(',')})`;
                        ctx.lineWidth = 4 * scale;
                        ctx.stroke();
                    }
                }
            }
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const checker = checkersBoard[row][col];
                    if (checker) {
                        drawChecker(x, y, row, col, checker, scaledCellSize);
                    }
                }
            }
            
            if (selectedChecker) {
                const [row, col] = selectedChecker;
                ctx.strokeStyle = `rgb(${SELECT_COLOR.join(',')})`;
                ctx.lineWidth = 5 * scale;
                ctx.strokeRect(
                    x + col * scaledCellSize + 5 * scale,
                    y + row * scaledCellSize + 5 * scale,
                    scaledCellSize - 10 * scale,
                    scaledCellSize - 10 * scale
                );
            }
        }
        
        function drawChecker(x, y, row, col, checker, cellSize) {
            const centerX = x + col * cellSize + cellSize / 2;
            const centerY = y + row * cellSize + cellSize / 2;
            const radius = checker.isKing ? cellSize / 2 - 14 * scale : cellSize / 2 - 10 * scale;
            
            const color = checker.color === 'white' ? WHITE : [50, 50, 50];
            ctx.fillStyle = `rgb(${color.join(',')})`;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            const outlineColor = checker.color === 'white' ? BLACK : [200, 200, 200];
            ctx.strokeStyle = `rgb(${outlineColor.join(',')})`;
            ctx.lineWidth = 4 * scale;
            ctx.stroke();
            
            if (checker.isKing) {
                ctx.fillStyle = `rgb(${YELLOW.join(',')})`;
                const crownSize = Math.max(26, cellSize / 2.3);
                ctx.font = `${crownSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ôî', centerX, centerY);
            }
        }
        
        function countCheckers(color) {
            let count = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const checker = checkersBoard[row][col];
                    if (checker && checker.color === color) {
                        count++;
                    }
                }
            }
            return count;
        }
        
        function handleCheckersClick(x, y) {
            if (showMenu || checkersGameOver || currentCheckersPlayer !== playerColor || moveInProgress) return;
            
            const boardX = (canvas.width - BOARD_SIZE * scale) / 2;
            const boardY = 130 * scale;
            const scaledCellSize = CELL_SIZE * scale;
            
            if (x >= boardX && x <= boardX + BOARD_SIZE * scale &&
                y >= boardY && y <= boardY + BOARD_SIZE * scale) {
                
                const col = Math.floor((x - boardX) / scaledCellSize);
                const row = Math.floor((y - boardY) / scaledCellSize);
                
                const checker = checkersBoard[row][col];
                if (checker && checker.color === currentCheckersPlayer) {
                    const allMoves = getAllPossibleCheckersMoves(currentCheckersPlayer);
                    const hasCaptures = allMoves.some(move => move[4]);
                    
                    if (hasCaptures && mandatoryCapture) {
                        const moves = getCheckerMoves(row, col, true);
                        if (moves.length > 0 && moves.some(m => m[2])) {
                            selectedChecker = [row, col];
                            possibleMoves = moves;
                        } else {
                            showNotification("–û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –≤–∑—è—Ç–∏–µ!", "–í—ã–±–µ—Ä–∏—Ç–µ —à–∞—à–∫—É, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç –≤–∑—è—Ç—å");
                        }
                    } else {
                        selectedChecker = [row, col];
                        possibleMoves = getCheckerMoves(row, col, false);
                    }
                }
                else if (selectedChecker) {
                    const [fromRow, fromCol] = selectedChecker;
                    const moveIndex = possibleMoves.findIndex(move => 
                        move[0] === row && move[1] === col);
                    
                    if (moveIndex !== -1) {
                        moveInProgress = true;
                        const [toRow, toCol, isCapture, capturedRow, capturedCol] = possibleMoves[moveIndex];
                        
                        checkersBoard[toRow][toCol] = checkersBoard[fromRow][fromCol];
                        checkersBoard[fromRow][fromCol] = null;
                        
                        if (isCapture && capturedRow !== undefined && capturedCol !== undefined) {
                            checkersBoard[capturedRow][capturedCol] = null;
                            playerStats.eaten_checkers++;
                            updateAchievement('tasty');
                            
                            const nextMoves = getCheckerMoves(toRow, toCol, true);
                            const hasMoreCaptures = nextMoves.some(m => m[2]);
                            
                            if (hasMoreCaptures && mandatoryCapture) {
                                selectedChecker = [toRow, toCol];
                                possibleMoves = nextMoves;
                                mustCapture = true;
                                moveInProgress = false;
                                return;
                            }
                        }
                        
                        if (!checkersBoard[toRow][toCol].isKing) {
                            if (checkersBoard[toRow][toCol].color === 'white' && toRow === 0) {
                                checkersBoard[toRow][toCol].isKing = true;
                                playerStats.kings_made++;
                            } else if (checkersBoard[toRow][toCol].color === 'black' && toRow === 7) {
                                checkersBoard[toRow][toCol].isKing = true;
                                playerStats.kings_made++;
                            }
                        }
                        
                        selectedChecker = null;
                        possibleMoves = [];
                        mustCapture = false;
                        
                        if (checkCheckersGameOver()) {
                            endCheckersGame();
                            moveInProgress = false;
                            return;
                        }
                        
                        currentCheckersPlayer = aiColor;
                        playerStats.games_played++;
                        
                        updateWelcomeMessage("–•–æ–¥ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ (—á–µ—Ä–Ω—ã–µ)", "–ü–æ–¥–æ–∂–¥–∏—Ç–µ...");
                        
                        setTimeout(makeAICheckersMove, 800);
                    }
                }
            }
        }
        
        function getCheckerMoves(row, col, checkCaptureOnly = false) {
            const checker = checkersBoard[row][col];
            if (!checker) return [];
            
            const moves = [];
            const directions = [];
            
            if (checker.isKing) {
                directions.push([-1, -1], [-1, 1], [1, -1], [1, 1]);
            } else if (checker.color === 'white') {
                directions.push([-1, -1], [-1, 1]);
            } else {
                directions.push([1, -1], [1, 1]);
            }
            
            for (const [dr, dc] of directions) {
                if (checker.isKing) {
                    for (let distance = 1; distance < 8; distance++) {
                        const newRow = row + dr * distance;
                        const newCol = col + dc * distance;
                        
                        if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                        
                        if (!checkersBoard[newRow][newCol]) {
                            if (!checkCaptureOnly) {
                                moves.push([newRow, newCol, false]);
                            }
                        } else {
                            if (checkersBoard[newRow][newCol].color === checker.color) {
                                break;
                            } else {
                                const jumpRow = newRow + dr;
                                const jumpCol = newCol + dc;
                                if (jumpRow >= 0 && jumpRow < 8 && jumpCol >= 0 && jumpCol < 8 &&
                                    !checkersBoard[jumpRow][jumpCol]) {
                                    moves.push([jumpRow, jumpCol, true, newRow, newCol]);
                                }
                                break;
                            }
                        }
                    }
                } else {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8 &&
                        !checkersBoard[newRow][newCol] && !checkCaptureOnly) {
                        moves.push([newRow, newCol, false]);
                    }
                    
                    const captureRow = row + dr * 2;
                    const captureCol = col + dc * 2;
                    if (captureRow >= 0 && captureRow < 8 && captureCol >= 0 && captureCol < 8 &&
                        !checkersBoard[captureRow][captureCol]) {
                        
                        const middleRow = row + dr;
                        const middleCol = col + dc;
                        if (middleRow >= 0 && middleRow < 8 && middleCol >= 0 && middleCol < 8) {
                            const middleChecker = checkersBoard[middleRow][middleCol];
                            if (middleChecker && middleChecker.color !== checker.color) {
                                moves.push([captureRow, captureCol, true, middleRow, middleCol]);
                            }
                        }
                    }
                }
            }
            
            return moves;
        }
        
        function getAllPossibleCheckersMoves(playerColor) {
            const allMoves = [];
            let hasCaptures = false;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const checker = checkersBoard[row][col];
                    if (checker && checker.color === playerColor) {
                        const moves = getCheckerMoves(row, col, false);
                        for (const move of moves) {
                            allMoves.push([row, col, ...move]);
                            if (move[2]) hasCaptures = true;
                        }
                    }
                }
            }
            
            if (hasCaptures && mandatoryCapture) {
                return allMoves.filter(move => move[4]);
            }
            
            return allMoves;
        }
        
        function checkCheckersGameOver() {
            const whiteMoves = getAllPossibleCheckersMoves('white');
            const blackMoves = getAllPossibleCheckersMoves('black');
            
            const whiteCount = countCheckers('white');
            const blackCount = countCheckers('black');
            
            if (whiteCount === 0) {
                checkersWinner = 'black';
                return true;
            }
            if (blackCount === 0) {
                checkersWinner = 'white';
                return true;
            }
            
            if (currentCheckersPlayer === 'white' && whiteMoves.length === 0) {
                checkersWinner = 'black';
                return true;
            }
            if (currentCheckersPlayer === 'black' && blackMoves.length === 0) {
                checkersWinner = 'white';
                return true;
            }
            
            return false;
        }
        
        function endCheckersGame() {
            checkersGameOver = true;
            
            const playerWon = checkersWinner === playerColor;
            
            if (playerWon) {
                playerStats.wins++;
                playerStats.consecutive_wins++;
                playerStats.consecutive_losses = 0;
                updateAchievement('winner');
                updateAchievement('absolute-winner', playerStats.consecutive_wins);
                updateAchievement('definitely-winner', playerStats.consecutive_wins);
                updateAchievement('king-of-kings', playerStats.consecutive_wins);
                
                showNotification("–ü–æ–±–µ–¥–∞!", "–í—ã –ø–æ–±–µ–¥–∏–ª–∏!");
                updateWelcomeMessage("–ü–æ–±–µ–¥–∞ –±–µ–ª—ã—Ö!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
            } else {
                playerStats.losses++;
                playerStats.consecutive_losses++;
                playerStats.consecutive_wins = 0;
                updateAchievement('hurry-up');
                updateAchievement('talentless', playerStats.consecutive_losses);
                
                showNotification("–ü–æ—Ä–∞–∂–µ–Ω–∏–µ", "–ü–æ–±–µ–¥–∏–ª–∏ —á–µ—Ä–Ω—ã–µ (–ò–ò)");
                updateWelcomeMessage("–ü–æ–±–µ–¥–∞ —á–µ—Ä–Ω—ã—Ö!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
            }
            
            saveProgress();
        }
        
        function makeAICheckersMove() {
            if (checkersGameOver) return;
            
            const allMoves = getAllPossibleCheckersMoves(aiColor);
            
            if (allMoves.length === 0) {
                endCheckersGame();
                return;
            }
            
            let captureMoves = allMoves.filter(move => move[4]);
            if (captureMoves.length > 0) {
                captureMoves.sort((a, b) => {
                    const pieceA = checkersBoard[a[0]][a[1]];
                    const pieceB = checkersBoard[b[0]][b[1]];
                    const isKingA = pieceA.isKing ? 2 : 0;
                    const isKingB = pieceB.isKing ? 2 : 0;
                    const targetA = checkersBoard[a[3]][a[4]];
                    const targetB = checkersBoard[b[3]][b[4]];
                    const targetValueA = targetA && targetA.isKing ? 3 : 1;
                    const targetValueB = targetB && targetB.isKing ? 3 : 1;
                    return (isKingB + targetValueB) - (isKingA + targetValueA);
                });
                
                const bestCapture = captureMoves[0];
                const [fromRow, fromCol, toRow, toCol, isCapture, capturedRow, capturedCol] = bestCapture;
                
                checkersBoard[toRow][toCol] = checkersBoard[fromRow][fromCol];
                checkersBoard[fromRow][fromCol] = null;
                
                if (isCapture && capturedRow !== undefined && capturedCol !== undefined) {
                    checkersBoard[capturedRow][capturedCol] = null;
                    playerStats.eaten_checkers++;
                }
                
                if (!checkersBoard[toRow][toCol].isKing) {
                    if (checkersBoard[toRow][toCol].color === 'white' && toRow === 0) {
                        checkersBoard[toRow][toCol].isKing = true;
                    } else if (checkersBoard[toRow][toCol].color === 'black' && toRow === 7) {
                        checkersBoard[toRow][toCol].isKing = true;
                    }
                }
                
                const nextMoves = getCheckerMoves(toRow, toCol, true);
                const hasMoreCaptures = nextMoves.some(m => m[2]);
                
                if (hasMoreCaptures && mandatoryCapture) {
                    setTimeout(() => {
                        const nextCaptureMoves = nextMoves.filter(m => m[2]);
                        if (nextCaptureMoves.length > 0) {
                            const [nextToRow, nextToCol, , nextCapturedRow, nextCapturedCol] = nextCaptureMoves[0];
                            checkersBoard[nextToRow][nextToCol] = checkersBoard[toRow][toCol];
                            checkersBoard[toRow][toCol] = null;
                            checkersBoard[nextCapturedRow][nextCapturedCol] = null;
                            playerStats.eaten_checkers++;
                            
                            if (checkCheckersGameOver()) {
                                endCheckersGame();
                                moveInProgress = false;
                                return;
                            }
                        }
                        currentCheckersPlayer = playerColor;
                        moveInProgress = false;
                        updateWelcomeMessage("–í–∞—à —Ö–æ–¥ (–±–µ–ª—ã–µ)", "–í—ã–±–µ—Ä–∏—Ç–µ —à–∞—à–∫—É");
                    }, 600);
                    return;
                }
            } else {
                let kingMoves = allMoves.filter(move => {
                    const [fromRow, fromCol, toRow] = move;
                    const piece = checkersBoard[fromRow][fromCol];
                    return !piece.isKing && 
                          ((piece.color === 'white' && toRow === 0) || 
                           (piece.color === 'black' && toRow === 7));
                });
                
                let centerMoves = allMoves.filter(move => {
                    const [, , toRow, toCol] = move;
                    return toCol >= 2 && toCol <= 5 && toRow >= 2 && toRow <= 5;
                });
                
                let attackMoves = allMoves.filter(move => {
                    const [fromRow, fromCol, toRow, toCol] = move;
                    const piece = checkersBoard[fromRow][fromCol];
                    if (piece.isKing) return true;
                    
                    return (piece.color === 'white' && toRow < fromRow) || 
                           (piece.color === 'black' && toRow > fromRow);
                });
                
                let safeMoves = allMoves.filter(move => {
                    const [fromRow, fromCol, toRow, toCol] = move;
                    let isSafe = true;
                    for (let dr of [-1, 1]) {
                        for (let dc of [-1, 1]) {
                            const attackRow = toRow + dr;
                            const attackCol = toCol + dc;
                            if (attackRow >= 0 && attackRow < 8 && attackCol >= 0 && attackCol < 8) {
                                const attacker = checkersBoard[attackRow][attackCol];
                                if (attacker && attacker.color !== aiColor && !attacker.isKing) {
                                    const jumpRow = toRow - dr;
                                    const jumpCol = toCol - dc;
                                    if (jumpRow >= 0 && jumpRow < 8 && jumpCol >= 0 && jumpCol < 8 &&
                                        !checkersBoard[jumpRow][jumpCol]) {
                                        isSafe = false;
                                    }
                                }
                            }
                        }
                    }
                    return isSafe;
                });
                
                let bestMoves = allMoves;
                if (kingMoves.length > 0) {
                    bestMoves = kingMoves;
                } else if (safeMoves.length > 0) {
                    bestMoves = safeMoves;
                } else if (centerMoves.length > 0) {
                    bestMoves = centerMoves;
                } else if (attackMoves.length > 0) {
                    bestMoves = attackMoves;
                }
                
                const randomMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];
                const [fromRow, fromCol, toRow, toCol] = randomMove;
                
                checkersBoard[toRow][toCol] = checkersBoard[fromRow][fromCol];
                checkersBoard[fromRow][fromCol] = null;
                
                if (!checkersBoard[toRow][toCol].isKing) {
                    if (checkersBoard[toRow][toCol].color === 'white' && toRow === 0) {
                        checkersBoard[toRow][toCol].isKing = true;
                    } else if (checkersBoard[toRow][toCol].color === 'black' && toRow === 7) {
                        checkersBoard[toRow][toCol].isKing = true;
                    }
                }
            }
            
            if (checkCheckersGameOver()) {
                endCheckersGame();
                moveInProgress = false;
                return;
            }
            
            currentCheckersPlayer = playerColor;
            moveInProgress = false;
            updateWelcomeMessage("–í–∞—à —Ö–æ–¥ (–±–µ–ª—ã–µ)", "–í—ã–±–µ—Ä–∏—Ç–µ —à–∞—à–∫—É");
        }
        
        function initChess() {
            chessBoard = Array(8).fill().map(() => Array(8).fill(null));
            
            playerColor = 'white';
            aiColor = 'black';
            playerIsWhite = true;
            
            // –ß–µ—Ä–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã (—Å–≤–µ—Ä—Ö—É)
            chessBoard[0] = [
                {type: 'r', color: 'black'},
                {type: 'n', color: 'black'},
                {type: 'b', color: 'black'},
                {type: 'q', color: 'black'},
                {type: 'k', color: 'black'},
                {type: 'b', color: 'black'},
                {type: 'n', color: 'black'},
                {type: 'r', color: 'black'}
            ];
            
            for (let col = 0; col < 8; col++) {
                chessBoard[1][col] = {type: 'p', color: 'black'};
            }
            
            // –ë–µ–ª—ã–µ —Ñ–∏–≥—É—Ä—ã (—Å–Ω–∏–∑—É)
            chessBoard[7] = [
                {type: 'r', color: 'white'},
                {type: 'n', color: 'white'},
                {type: 'b', color: 'white'},
                {type: 'q', color: 'white'},
                {type: 'k', color: 'white'},
                {type: 'b', color: 'white'},
                {type: 'n', color: 'white'},
                {type: 'r', color: 'white'}
            ];
            
            for (let col = 0; col < 8; col++) {
                chessBoard[6][col] = {type: 'p', color: 'white'};
            }
            
            currentChessPlayer = 'white';
            selectedChessPiece = null;
            chessPossibleMoves = [];
            chessGameOver = false;
            chessWinner = null;
            isCheck = false;
            checkKingPos = null;
            chessCaptureTargets = [];
            waitingForPromotion = false;
            promotionPawn = null;
            promotionColor = null;
            kingCheckAnimation = false;
            kingCheckAnimationFrame = 0;
            kingCheckPosition = null;
            
            playerStats.chess_games++;
            restartBtn.classList.remove('hidden');
            backToModeBtn.classList.remove('hidden');
            hideMenu();
            
            updateWelcomeMessage("–í–∞—à —Ö–æ–¥ (–±–µ–ª—ã–µ)", "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É");
        }
        
        function drawChessScreen() {
            clearCanvas();
            
            ctx.fillStyle = `rgb(${WHITE.join(',')})`;
            const titleSize = Math.min(canvas.width * 0.05, 28);
            ctx.font = `bold ${titleSize}px Arial`;
            ctx.textAlign = 'center';
            
            // –í–ï–†–ù–£–õ: –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∏–≥—Ä—ã (—á–µ–π —Ö–æ–¥, —à–∞—Ö)
            if (chessGameOver) {
                const winnerText = chessWinner === 'white' ? '–ë–ï–õ–´–ï (–ò–ì–†–û–ö)' : '–ß–ï–†–ù–´–ï (–ò–ò)';
                const gameOverText = `–®–ê–• –ò –ú–ê–¢! –ü–û–ë–ï–î–ò–õ–ò: ${winnerText}`;
                
                const maxWidth = canvas.width * 0.9;
                const textWidth = ctx.measureText(gameOverText).width;
                
                if (textWidth > maxWidth) {
                    const parts = gameOverText.split(': ');
                    if (parts.length > 1) {
                        ctx.fillText(parts[0] + ':', canvas.width / 2, 60 * scale);
                        ctx.fillText(parts[1], canvas.width / 2, 90 * scale);
                    } else {
                        ctx.fillText(gameOverText.substring(0, Math.floor(gameOverText.length * 0.8)) + '...', 
                                    canvas.width / 2, 70 * scale);
                    }
                } else {
                    ctx.fillText(gameOverText, canvas.width / 2, 70 * scale);
                }
            } else {
                let status = currentChessPlayer === playerColor ? "–í–ê–® –•–û–î (–ë–ï–õ–´–ï)" : "–•–û–î –ö–û–ú–ü–¨–Æ–¢–ï–†–ê (–ß–ï–†–ù–´–ï)";
                if (isCheck) {
                    status += " - –®–ê–•!";
                }
                
                const maxWidth = canvas.width * 0.9;
                const textWidth = ctx.measureText(status).width;
                
                if (textWidth > maxWidth) {
                    const smallerSize = Math.min(canvas.width * 0.04, 22);
                    ctx.font = `bold ${smallerSize}px Arial`;
                    
                    const newTextWidth = ctx.measureText(status).width;
                    if (newTextWidth > maxWidth) {
                        if (isCheck) {
                            const mainPart = currentChessPlayer === playerColor ? "–í–ê–® –•–û–î (–ë–ï–õ–´–ï)" : "–•–û–î –ö–û–ú–ü–¨–Æ–¢–ï–†–ê (–ß–ï–†–ù–´–ï)";
                            ctx.fillText(mainPart, canvas.width / 2, 60 * scale);
                            ctx.fillText("–®–ê–•!", canvas.width / 2, 90 * scale);
                        } else {
                            ctx.fillText(status, canvas.width / 2, 70 * scale);
                        }
                    } else {
                        ctx.fillText(status, canvas.width / 2, 70 * scale);
                    }
                    ctx.font = `bold ${titleSize}px Arial`;
                } else {
                    ctx.fillText(status, canvas.width / 2, 70 * scale);
                }
            }
            
            const boardX = (canvas.width - BOARD_SIZE * scale) / 2;
            const boardY = 130 * scale;
            
            ctx.fillStyle = 'rgb(44, 62, 80)';
            ctx.fillRect(boardX - 12 * scale, boardY - 12 * scale, 
                BOARD_SIZE * scale + 24 * scale, BOARD_SIZE * scale + 24 * scale);
            
            drawChessBoard(boardX, boardY);
            
            return SCREENS.chess;
        }
        
        function drawChessBoard(x, y) {
            const scaledCellSize = CELL_SIZE * scale;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cellColor = (row + col) % 2 === 0 ? BOARD_LIGHT : BOARD_DARK;
                    ctx.fillStyle = `rgb(${cellColor.join(',')})`;
                    ctx.fillRect(
                        x + col * scaledCellSize,
                        y + row * scaledCellSize,
                        scaledCellSize,
                        scaledCellSize
                    );
                }
            }
            
            if (selectedChessPiece) {
                for (const move of chessPossibleMoves) {
                    const [toRow, toCol] = move;
                    const centerX = x + toCol * scaledCellSize + scaledCellSize / 2;
                    const centerY = y + toRow * scaledCellSize + scaledCellSize / 2;
                    const radius = scaledCellSize / 4.5;
                    
                    ctx.fillStyle = `rgba(${MOVE_COLOR[0]}, ${MOVE_COLOR[1]}, ${MOVE_COLOR[2]}, 0.7)`;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                for (const target of chessCaptureTargets) {
                    const [targetRow, targetCol] = target;
                    ctx.strokeStyle = `rgba(${CAPTURE_HIGHLIGHT[0]}, ${CAPTURE_HIGHLIGHT[1]}, ${CAPTURE_HIGHLIGHT[2]}, 0.7)`;
                    ctx.lineWidth = 6 * scale;
                    ctx.strokeRect(
                        x + targetCol * scaledCellSize + 4 * scale,
                        y + targetRow * scaledCellSize + 4 * scale,
                        scaledCellSize - 8 * scale,
                        scaledCellSize - 8 * scale
                    );
                }
            }
            
            // –†–∏—Å—É–µ–º –∫—Ä–∞—Å–Ω–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ –¥–ª—è –∫–æ—Ä–æ–ª—è –ø–æ–¥ —à–∞—Ö–æ–º
            if (kingCheckAnimation && kingCheckPosition) {
                const [row, col] = kingCheckPosition;
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –ø—É–ª—å—Å–∞—Ü–∏–∏ —Ñ–æ–Ω–∞ –∫–ª–µ—Ç–∫–∏
                kingCheckAnimationFrame = (kingCheckAnimationFrame + 0.1) % (Math.PI * 2);
                const pulseIntensity = Math.sin(kingCheckAnimationFrame) * 0.5 + 0.5;
                
                ctx.fillStyle = `rgba(255, 50, 50, ${0.3 + pulseIntensity * 0.5})`;
                ctx.fillRect(
                    x + col * scaledCellSize,
                    y + row * scaledCellSize,
                    scaledCellSize,
                    scaledCellSize
                );
            }
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = chessBoard[row][col];
                    if (piece) {
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–∞ —Ñ–∏–≥—É—Ä–∞ –∫–æ—Ä–æ–ª–µ–º –ø–æ–¥ —à–∞—Ö–æ–º
                        const isKingInCheck = kingCheckPosition && 
                                               kingCheckPosition[0] === row && 
                                               kingCheckPosition[1] === col;
                        
                        drawChessPiece(x, y, row, col, piece, scaledCellSize, isKingInCheck);
                    }
                }
            }
            
            if (selectedChessPiece) {
                const [row, col] = selectedChessPiece;
                ctx.strokeStyle = `rgb(${SELECT_COLOR.join(',')})`;
                ctx.lineWidth = 5 * scale;
                ctx.strokeRect(
                    x + col * scaledCellSize + 5 * scale,
                    y + row * scaledCellSize + 5 * scale,
                    scaledCellSize - 10 * scale,
                    scaledCellSize - 10 * scale
                );
            }
        }
        
        function drawChessPiece(x, y, row, col, piece, cellSize, isInCheck = false) {
            const centerX = x + col * cellSize + cellSize / 2;
            const centerY = y + row * cellSize + cellSize / 2;
            
            const pieceInfo = chessPieces[piece.type];
            const color = piece.color === 'white' ? WHITE : [50, 50, 50];
            
            // –†–∏—Å—É–µ–º –∫—Ä–∞—Å–Ω–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ –¥–ª—è –∫–æ—Ä–æ–ª—è –ø–æ–¥ —à–∞—Ö–æ–º
            if (isInCheck && piece.type === 'k') {
                // –í–Ω–µ—à–Ω–µ–µ —Å–≤–µ—á–µ–Ω–∏–µ
                ctx.save();
                kingCheckAnimationFrame = (kingCheckAnimationFrame + 0.1) % (Math.PI * 2);
                const glowIntensity = Math.sin(kingCheckAnimationFrame) * 0.5 + 0.5;
                
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, cellSize / 3,
                    centerX, centerY, cellSize / 2
                );
                gradient.addColorStop(0, `rgba(255, 0, 0, ${0.7 + glowIntensity * 0.3})`);
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, cellSize / 1.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // –ö—Ä–∞—Å–Ω—ã–π –∫–æ–Ω—Ç—É—Ä –¥–ª—è –∫–æ—Ä–æ–ª—è
                ctx.strokeStyle = `rgba(255, 0, 0, ${0.8 + glowIntensity * 0.2})`;
                ctx.lineWidth = 8 * scale;
                ctx.beginPath();
                ctx.arc(centerX, centerY, cellSize / 2.3, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.fillStyle = `rgb(${color.join(',')})`;
            ctx.beginPath();
            ctx.arc(centerX, centerY, cellSize / 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = piece.color === 'white' ? `rgb(${BLACK.join(',')})` : `rgb(${WHITE.join(',')})`;
            ctx.lineWidth = 4 * scale;
            ctx.stroke();
            
            // –î–ª—è –∫–æ—Ä–æ–ª—è –ø–æ–¥ —à–∞—Ö–æ–º –¥–µ–ª–∞–µ–º —Å–∏–º–≤–æ–ª –∫—Ä–∞—Å–Ω—ã–º
            if (isInCheck && piece.type === 'k') {
                ctx.fillStyle = `rgb(${RED.join(',')})`;
            } else {
                ctx.fillStyle = piece.color === 'white' ? `rgb(${BLACK.join(',')})` : `rgb(${WHITE.join(',')})`;
            }
            
            const symbolSize = Math.max(30, cellSize / 1.8);
            ctx.font = `bold ${symbolSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(pieceInfo.symbol, centerX, centerY);
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –ø—É–ª—å—Å–∏—Ä—É—é—â–µ–µ —Å–≤–µ—á–µ–Ω–∏–µ –¥–ª—è –∫–æ—Ä–æ–ª—è –ø–æ–¥ —à–∞—Ö–æ–º
            if (isInCheck && piece.type === 'k') {
                kingCheckAnimationFrame = (kingCheckAnimationFrame + 0.1) % (Math.PI * 2);
                const pulse = Math.sin(kingCheckAnimationFrame) * 0.3 + 0.7;
                
                ctx.strokeStyle = `rgba(255, 100, 100, ${pulse})`;
                ctx.lineWidth = 6 * scale;
                ctx.beginPath();
                ctx.arc(centerX, centerY, cellSize / 2.3, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        function handleChessClick(x, y) {
            if (showMenu || chessGameOver || moveInProgress || waitingForPromotion) return;
            
            if (currentChessPlayer !== playerColor) {
                return;
            }
            
            const boardX = (canvas.width - BOARD_SIZE * scale) / 2;
            const boardY = 130 * scale;
            const scaledCellSize = CELL_SIZE * scale;
            
            if (x >= boardX && x <= boardX + BOARD_SIZE * scale &&
                y >= boardY && y <= boardY + BOARD_SIZE * scale) {
                
                const col = Math.floor((x - boardX) / scaledCellSize);
                const row = Math.floor((y - boardY) / scaledCellSize);
                
                const piece = chessBoard[row][col];
                
                if (selectedChessPiece) {
                    const [fromRow, fromCol] = selectedChessPiece;
                    const moveIndex = chessPossibleMoves.findIndex(move => 
                        move[0] === row && move[1] === col);
                    
                    if (moveIndex !== -1) {
                        moveInProgress = true;
                        
                        const targetPiece = chessBoard[row][col];
                        if (targetPiece && targetPiece.type === 'k') {
                            showNotification("–ù–µ–ª—å–∑—è —Å—ä–µ—Å—Ç—å –∫–æ—Ä–æ–ª—è!", "–ö–æ—Ä–æ–ª—è –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å –≤ –º–∞—Ç");
                            moveInProgress = false;
                            return;
                        }
                        
                        const oldBoard = JSON.parse(JSON.stringify(chessBoard));
                        
                        chessBoard[row][col] = chessBoard[fromRow][fromCol];
                        chessBoard[fromRow][fromCol] = null;
                        
                        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏
                        const movedPiece = chessBoard[row][col];
                        if (movedPiece.type === 'p') {
                            if ((movedPiece.color === 'white' && row === 0) || 
                                (movedPiece.color === 'black' && row === 7)) {
                                promotionPawn = [row, col];
                                promotionColor = movedPiece.color;
                                waitingForPromotion = true;
                                promotionOverlay.classList.remove('hidden');
                                moveInProgress = false;
                                return;
                            }
                        }
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–æ—Å—Ç–∞–≤–∏–ª–∏ –ª–∏ –º—ã —Å–≤–æ–µ–≥–æ –∫–æ—Ä–æ–ª—è –ø–æ–¥ —à–∞—Ö
                        checkForCheck();
                        if (isCheck && currentChessPlayer === playerColor) {
                            chessBoard = oldBoard;
                            showNotification("–ù–µ–ª—å–∑—è —Ö–æ–¥–∏—Ç—å!", "–í—ã –ø–æ—Å—Ç–∞–≤–∏–ª–∏ —Å–≤–æ–µ–≥–æ –∫–æ—Ä–æ–ª—è –ø–æ–¥ —à–∞—Ö");
                            moveInProgress = false;
                            checkForCheck();
                            return;
                        }
                        
                        currentChessPlayer = aiColor;
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∏—á—å—é (—Ç–æ–ª—å–∫–æ –¥–≤–∞ –∫–æ—Ä–æ–ª—è)
                        if (checkKingsOnlyDraw()) {
                            chessGameOver = true;
                            showNotification("–ù–ò–ß–¨–Ø!", "–ù–∞ –¥–æ—Å–∫–µ –æ—Å—Ç–∞–ª–∏—Å—å —Ç–æ–ª—å–∫–æ –¥–≤–∞ –∫–æ—Ä–æ–ª—è");
                            updateWelcomeMessage("–ù–∏—á—å—è!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                            playerStats.draws++;
                            playerStats.games_played++;
                            saveProgress();
                            selectedChessPiece = null;
                            chessPossibleMoves = [];
                            chessCaptureTargets = [];
                            moveInProgress = false;
                            return;
                        }
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∏—á—å—é (–ø–∞—Ç - –Ω–µ—Ç —Ö–æ–¥–æ–≤ —É –æ–±–æ–∏—Ö)
                        if (checkStalemateDraw()) {
                            chessGameOver = true;
                            showNotification("–ù–ò–ß–¨–Ø!", "–ù–µ—Ç –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤ —É –æ–±–æ–∏—Ö –∏–≥—Ä–æ–∫–æ–≤");
                            updateWelcomeMessage("–ù–∏—á—å—è!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                            playerStats.draws++;
                            playerStats.games_played++;
                            saveProgress();
                            selectedChessPiece = null;
                            chessPossibleMoves = [];
                            chessCaptureTargets = [];
                            moveInProgress = false;
                            return;
                        }
                        
                        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —à–∞—Ö–µ, –µ—Å–ª–∏ –ø–æ—Å—Ç–∞–≤–∏–ª–∏ —à–∞—Ö
                        checkForCheck();
                        if (isCheck && checkForMate()) {
                            // –®–∞—Ö –∏ –º–∞—Ç - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
                            chessGameOver = true;
                            chessWinner = playerColor;
                            showCheckmateNotification(playerColor);
                            updateWelcomeMessage("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                            playerStats.wins++;
                            playerStats.games_played++;
                            saveProgress();
                            selectedChessPiece = null;
                            chessPossibleMoves = [];
                            chessCaptureTargets = [];
                            moveInProgress = false;
                            return;
                        } else if (isCheck) {
                            // –ü—Ä–æ—Å—Ç–æ —à–∞—Ö - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–∞ 3 —Å–µ–∫—É–Ω–¥—ã
                            showCheckNotification(false);
                        }
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ç
                        if (!hasAnyValidMove(aiColor)) {
                            if (isCheck) {
                                chessGameOver = true;
                                chessWinner = playerColor;
                                showCheckmateNotification(playerColor);
                                updateWelcomeMessage("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                            } else {
                                chessGameOver = true;
                                showNotification("–ü–∞—Ç!", "–ù–∏—á—å—è!");
                                updateWelcomeMessage("–ù–∏—á—å—è!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                                playerStats.draws++;
                            }
                            playerStats.games_played++;
                            saveProgress();
                            selectedChessPiece = null;
                            chessPossibleMoves = [];
                            chessCaptureTargets = [];
                            moveInProgress = false;
                            return;
                        }
                        
                        selectedChessPiece = null;
                        chessPossibleMoves = [];
                        chessCaptureTargets = [];
                        
                        updateWelcomeMessage("–•–æ–¥ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ (—á–µ—Ä–Ω—ã–µ)", "–ü–æ–¥–æ–∂–¥–∏—Ç–µ...");
                        
                        setTimeout(makeAIChessMove, 800);
                        return;
                    }
                }
                
                if (piece && piece.color === currentChessPlayer) {
                    selectedChessPiece = [row, col];
                    chessPossibleMoves = getChessMoves(row, col, piece);
                    chessCaptureTargets = [];
                    
                    for (const move of chessPossibleMoves) {
                        const [toRow, toCol] = move;
                        const target = chessBoard[toRow][toCol];
                        if (target && target.color !== piece.color && target.type !== 'k') {
                            if (!chessCaptureTargets.some(t => t[0] === toRow && t[1] === toCol)) {
                                chessCaptureTargets.push([toRow, toCol]);
                            }
                        }
                    }
                } else {
                    selectedChessPiece = null;
                    chessPossibleMoves = [];
                    chessCaptureTargets = [];
                }
            }
        }
        
        function getChessMoves(row, col, piece) {
            const moves = [];
            const pieceType = piece.type;
            const color = piece.color;
            const opponent = color === 'white' ? 'black' : 'white';
            
            switch(pieceType) {
                case 'p': // –ü–µ—à–∫–∞
                    const direction = color === 'white' ? -1 : 1;
                    const startRow = color === 'white' ? 6 : 1;
                    
                    // –•–æ–¥ –≤–ø–µ—Ä–µ–¥ –Ω–∞ –æ–¥–Ω—É –∫–ª–µ—Ç–∫—É
                    if (row + direction >= 0 && row + direction < 8) {
                        if (!chessBoard[row + direction][col]) {
                            moves.push([row + direction, col]);
                            
                            // –ü–µ—Ä–≤—ã–π —Ö–æ–¥ –ø–µ—à–∫–∏ - –Ω–∞ –¥–≤–µ –∫–ª–µ—Ç–∫–∏
                            if (row === startRow && !chessBoard[row + 2 * direction][col]) {
                                moves.push([row + 2 * direction, col]);
                            }
                        }
                    }
                    
                    // –í–∑—è—Ç–∏–µ –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏
                    for (let dc of [-1, 1]) {
                        const newCol = col + dc;
                        if (newCol >= 0 && newCol < 8 && row + direction >= 0 && row + direction < 8) {
                            const target = chessBoard[row + direction][newCol];
                            if (target && target.color === opponent) {
                                moves.push([row + direction, newCol]);
                            }
                        }
                    }
                    break;
                    
                case 'r': // –õ–∞–¥—å—è
                    const rookDirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dr, dc] of rookDirs) {
                        let newRow = row + dr;
                        let newCol = col + dc;
                        while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (!chessBoard[newRow][newCol]) {
                                moves.push([newRow, newCol]);
                            } else {
                                if (chessBoard[newRow][newCol].color === opponent) {
                                    moves.push([newRow, newCol]);
                                }
                                break;
                            }
                            newRow += dr;
                            newCol += dc;
                        }
                    }
                    break;
                    
                case 'n': // –ö–æ–Ω—å
                    const knightMoves = [
                        [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                        [1, -2], [1, 2], [2, -1], [2, 1]
                    ];
                    for (const [dr, dc] of knightMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (!chessBoard[newRow][newCol] || chessBoard[newRow][newCol].color === opponent) {
                                moves.push([newRow, newCol]);
                            }
                        }
                    }
                    break;
                    
                case 'b': // –°–ª–æ–Ω
                    const bishopDirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    for (const [dr, dc] of bishopDirs) {
                        let newRow = row + dr;
                        let newCol = col + dc;
                        while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (!chessBoard[newRow][newCol]) {
                                moves.push([newRow, newCol]);
                            } else {
                                if (chessBoard[newRow][newCol].color === opponent) {
                                    moves.push([newRow, newCol]);
                                }
                                break;
                            }
                            newRow += dr;
                            newCol += dc;
                        }
                    }
                    break;
                    
                case 'q': // –§–µ—Ä–∑—å
                    const queenDirs = [
                        [-1, -1], [-1, 1], [1, -1], [1, 1],
                        [-1, 0], [1, 0], [0, -1], [0, 1]
                    ];
                    for (const [dr, dc] of queenDirs) {
                        let newRow = row + dr;
                        let newCol = col + dc;
                        while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (!chessBoard[newRow][newCol]) {
                                moves.push([newRow, newCol]);
                            } else {
                                if (chessBoard[newRow][newCol].color === opponent) {
                                    moves.push([newRow, newCol]);
                                }
                                break;
                            }
                            newRow += dr;
                            newCol += dc;
                        }
                    }
                    break;
                    
                case 'k': // –ö–æ—Ä–æ–ª—å
                    const kingMoves = [
                        [-1, -1], [-1, 0], [-1, 1],
                        [0, -1],           [0, 1],
                        [1, -1], [1, 0], [1, 1]
                    ];
                    for (const [dr, dc] of kingMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (!chessBoard[newRow][newCol] || chessBoard[newRow][newCol].color === opponent) {
                                moves.push([newRow, newCol]);
                            }
                        }
                    }
                    break;
            }
            
            // –§–∏–ª—å—Ç—Ä—É–µ–º —Ö–æ–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ —Å—Ç–∞–≤—è—Ç —Å–≤–æ–µ–≥–æ –∫–æ—Ä–æ–ª—è –ø–æ–¥ —à–∞—Ö
            const filteredMoves = [];
            for (const move of moves) {
                const [toRow, toCol] = move;
                
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ö–æ–¥, –µ—Å–ª–∏ –ø—ã—Ç–∞–µ–º—Å—è —Å—ä–µ—Å—Ç—å –∫–æ—Ä–æ–ª—è
                const targetPiece = chessBoard[toRow][toCol];
                if (targetPiece && targetPiece.type === 'k') {
                    continue;
                }
                
                const oldBoard = JSON.parse(JSON.stringify(chessBoard));
                
                // –î–µ–ª–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ö–æ–¥
                chessBoard[toRow][toCol] = chessBoard[row][col];
                chessBoard[row][col] = null;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–æ—Å—Ç–∞–≤–∏–ª–∏ –ª–∏ –º—ã —Å–≤–æ–µ–≥–æ –∫–æ—Ä–æ–ª—è –ø–æ–¥ —à–∞—Ö
                let kingInCheck = false;
                
                // –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é –∫–æ—Ä–æ–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞
                let kingPos = null;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = chessBoard[r][c];
                        if (p && p.type === 'k' && p.color === color) {
                            kingPos = [r, c];
                            break;
                        }
                    }
                    if (kingPos) break;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞—Ç–∞–∫–æ–≤–∞–Ω –ª–∏ –∫–æ—Ä–æ–ª—å
                if (kingPos) {
                    kingInCheck = isSquareAttacked(kingPos[0], kingPos[1], opponent);
                }
                
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–æ—Å–∫—É
                chessBoard = oldBoard;
                
                if (!kingInCheck) {
                    filteredMoves.push(move);
                }
            }
            
            return filteredMoves;
        }
        
        function isSquareAttacked(row, col, attackingColor) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = chessBoard[r][c];
                    if (piece && piece.color === attackingColor) {
                        const moves = getSimpleChessMoves(r, c, piece, true);
                        if (moves.some(([mr, mc]) => mr === row && mc === col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function getSimpleChessMoves(row, col, piece, includePseudo = false) {
            const moves = [];
            const pieceType = piece.type;
            const color = piece.color;
            const opponent = color === 'white' ? 'black' : 'white';
            
            switch(pieceType) {
                case 'p': // –ü–µ—à–∫–∞
                    const direction = color === 'white' ? -1 : 1;
                    
                    // –í–∑—è—Ç–∏–µ –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏
                    for (let dc of [-1, 1]) {
                        const newCol = col + dc;
                        if (newCol >= 0 && newCol < 8 && row + direction >= 0 && row + direction < 8) {
                            moves.push([row + direction, newCol]);
                        }
                    }
                    break;
                    
                case 'r': // –õ–∞–¥—å—è
                    const rookDirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dr, dc] of rookDirs) {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + dr * i;
                            const newCol = col + dc * i;
                            if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                            moves.push([newRow, newCol]);
                            if (chessBoard[newRow][newCol]) break;
                        }
                    }
                    break;
                    
                case 'n': // –ö–æ–Ω—å
                    const knightMoves = [
                        [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                        [1, -2], [1, 2], [2, -1], [2, 1]
                    ];
                    for (const [dr, dc] of knightMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            moves.push([newRow, newCol]);
                        }
                    }
                    break;
                    
                case 'b': // –°–ª–æ–Ω
                    const bishopDirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    for (const [dr, dc] of bishopDirs) {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + dr * i;
                            const newCol = col + dc * i;
                            if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                            moves.push([newRow, newCol]);
                            if (chessBoard[newRow][newCol]) break;
                        }
                    }
                    break;
                    
                case 'q': // –§–µ—Ä–∑—å
                    const queenDirs = [
                        [-1, -1], [-1, 1], [1, -1], [1, 1],
                        [-1, 0], [1, 0], [0, -1], [0, 1]
                    ];
                    for (const [dr, dc] of queenDirs) {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + dr * i;
                            const newCol = col + dc * i;
                            if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                            moves.push([newRow, newCol]);
                            if (chessBoard[newRow][newCol]) break;
                        }
                    }
                    break;
                    
                case 'k': // –ö–æ—Ä–æ–ª—å
                    const kingMoves = [
                        [-1, -1], [-1, 0], [-1, 1],
                        [0, -1],           [0, 1],
                        [1, -1], [1, 0], [1, 1]
                    ];
                    for (const [dr, dc] of kingMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            moves.push([newRow, newCol]);
                        }
                    }
                    break;
            }
            
            return moves;
        }
        
        function hasAnyValidMove(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = chessBoard[row][col];
                    if (piece && piece.color === color) {
                        const moves = getChessMoves(row, col, piece);
                        if (moves.length > 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function checkForCheck() {
            isCheck = false;
            checkKingPos = null;
            kingCheckAnimation = false;
            kingCheckPosition = null;
            
            // –ù–∞—Ö–æ–¥–∏–º –∫–æ—Ä–æ–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞
            let kingPos = null;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = chessBoard[row][col];
                    if (piece && piece.type === 'k' && piece.color === currentChessPlayer) {
                        kingPos = [row, col];
                        break;
                    }
                }
                if (kingPos) break;
            }
            
            if (!kingPos) return;
            
            const opponent = currentChessPlayer === 'white' ? 'black' : 'white';
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞—Ç–∞–∫–æ–≤–∞–Ω –ª–∏ –∫–æ—Ä–æ–ª—å
            isCheck = isSquareAttacked(kingPos[0], kingPos[1], opponent);
            if (isCheck) {
                checkKingPos = kingPos;
                kingCheckAnimation = true;
                kingCheckPosition = kingPos;
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —à–∞—Ö–µ –Ω–∞ 3 —Å–µ–∫—É–Ω–¥—ã
                showCheckNotification(currentChessPlayer === playerColor);
            }
        }
        
        function checkForMate() {
            if (!isCheck) return false;
            
            // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –ª—é–±–æ–π —Ö–æ–¥, –∫–æ—Ç–æ—Ä—ã–π —É–±–∏—Ä–∞–µ—Ç –∫–æ—Ä–æ–ª—è –∏–∑-–ø–æ–¥ —à–∞—Ö–∞
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = chessBoard[row][col];
                    if (piece && piece.color === currentChessPlayer) {
                        const moves = getChessMoves(row, col, piece);
                        
                        for (const move of moves) {
                            const [toRow, toCol] = move;
                            
                            const oldBoard = JSON.parse(JSON.stringify(chessBoard));
                            
                            chessBoard[toRow][toCol] = chessBoard[row][col];
                            chessBoard[row][col] = null;
                            
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ—Å—Ç–∞–ª—Å—è –ª–∏ –∫–æ—Ä–æ–ª—å –ø–æ–¥ —à–∞—Ö–æ–º
                            let kingPos = null;
                            for (let r = 0; r < 8; r++) {
                                for (let c = 0; c < 8; c++) {
                                    const p = chessBoard[r][c];
                                    if (p && p.type === 'k' && p.color === currentChessPlayer) {
                                        kingPos = [r, c];
                                        break;
                                    }
                                }
                                if (kingPos) break;
                            }
                            
                            const opponent = currentChessPlayer === 'white' ? 'black' : 'white';
                            const stillInCheck = kingPos ? isSquareAttacked(kingPos[0], kingPos[1], opponent) : false;
                            
                            chessBoard = oldBoard;
                            
                            if (!stillInCheck) {
                                return false;
                            }
                        }
                    }
                }
            }
            
            return true;
        }
        
        function makeAIChessMove() {
            if (chessGameOver) return;
            
            const allMoves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = chessBoard[row][col];
                    if (piece && piece.color === aiColor) {
                        const moves = getChessMoves(row, col, piece);
                        for (const move of moves) {
                            allMoves.push([row, col, ...move]);
                        }
                    }
                }
            }
            
            if (allMoves.length === 0) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∏—á—å—é (—Ç–æ–ª—å–∫–æ –¥–≤–∞ –∫–æ—Ä–æ–ª—è)
                if (checkKingsOnlyDraw()) {
                    chessGameOver = true;
                    showNotification("–ù–ò–ß–¨–Ø!", "–ù–∞ –¥–æ—Å–∫–µ –æ—Å—Ç–∞–ª–∏—Å—å —Ç–æ–ª—å–∫–æ –¥–≤–∞ –∫–æ—Ä–æ–ª—è");
                    updateWelcomeMessage("–ù–∏—á—å—è!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                    playerStats.draws++;
                    playerStats.games_played++;
                    saveProgress();
                    return;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∏—á—å—é (–ø–∞—Ç - –Ω–µ—Ç —Ö–æ–¥–æ–≤ —É –æ–±–æ–∏—Ö)
                if (checkStalemateDraw()) {
                    chessGameOver = true;
                    showNotification("–ù–ò–ß–¨–Ø!", "–ù–µ—Ç –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤ —É –æ–±–æ–∏—Ö –∏–≥—Ä–æ–∫–æ–≤");
                    updateWelcomeMessage("–ù–∏—á—å—è!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                    playerStats.draws++;
                    playerStats.games_played++;
                    saveProgress();
                    return;
                }
                
                checkForCheck();
                if (isCheck) {
                    chessGameOver = true;
                    chessWinner = playerColor;
                    showCheckmateNotification(playerColor);
                    updateWelcomeMessage("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                    playerStats.wins++;
                    playerStats.games_played++;
                    saveProgress();
                } else {
                    chessGameOver = true;
                    showNotification("–ü–∞—Ç!", "–ù–∏—á—å—è!");
                    updateWelcomeMessage("–ù–∏—á—å—è!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                    playerStats.draws++;
                    playerStats.games_played++;
                    saveProgress();
                }
                return;
            }
            
            // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ —Ö–æ–¥—ã: –≤–∑—è—Ç–∏—è, —à–∞—Ö, –∑–∞—â–∏—Ç–∞
            let captureMoves = [];
            let checkMoves = [];
            let normalMoves = [];
            
            for (const move of allMoves) {
                const [fromRow, fromCol, toRow, toCol] = move;
                const targetPiece = chessBoard[toRow][toCol];
                
                if (targetPiece) {
                    captureMoves.push(move);
                } else {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—Ç–∞–≤–∏—Ç –ª–∏ —Ö–æ–¥ —à–∞—Ö
                    const oldBoard = JSON.parse(JSON.stringify(chessBoard));
                    chessBoard[toRow][toCol] = chessBoard[fromRow][fromCol];
                    chessBoard[fromRow][fromCol] = null;
                    
                    // –ù–∞—Ö–æ–¥–∏–º –∫–æ—Ä–æ–ª—è –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
                    let kingPos = null;
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            const p = chessBoard[r][c];
                            if (p && p.type === 'k' && p.color === playerColor) {
                                kingPos = [r, c];
                                break;
                            }
                        }
                        if (kingPos) break;
                    }
                    
                    const putsCheck = kingPos ? isSquareAttacked(kingPos[0], kingPos[1], aiColor) : false;
                    chessBoard = oldBoard;
                    
                    if (putsCheck) {
                        checkMoves.push(move);
                    } else {
                        normalMoves.push(move);
                    }
                }
            }
            
            let chosenMove;
            if (captureMoves.length > 0) {
                // –í—ã–±–∏—Ä–∞–µ–º —Å–∞–º–æ–µ —Ü–µ–Ω–Ω–æ–µ –≤–∑—è—Ç–∏–µ
                captureMoves.sort((a, b) => {
                    const targetA = chessBoard[a[3]][a[4]];
                    const targetB = chessBoard[b[3]][b[4]];
                    const valueA = targetA ? chessPieces[targetA.type].value : 0;
                    const valueB = targetB ? chessPieces[targetB.type].value : 0;
                    return valueB - valueA;
                });
                chosenMove = captureMoves[0];
            } else if (checkMoves.length > 0) {
                chosenMove = checkMoves[Math.floor(Math.random() * checkMoves.length)];
            } else {
                chosenMove = allMoves[Math.floor(Math.random() * allMoves.length)];
            }
            
            const [fromRow, fromCol, toRow, toCol] = chosenMove;
            
            // –î–µ–ª–∞–µ–º —Ö–æ–¥
            chessBoard[toRow][toCol] = chessBoard[fromRow][fromCol];
            chessBoard[fromRow][fromCol] = null;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏ –ò–ò
            const movedPiece = chessBoard[toRow][toCol];
            if (movedPiece.type === 'p') {
                if ((movedPiece.color === 'white' && toRow === 0) || 
                    (movedPiece.color === 'black' && toRow === 7)) {
                    // –ò–ò –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –ø–µ—à–∫—É –≤ —Ñ–µ—Ä–∑—è
                    chessBoard[toRow][toCol] = {type: 'q', color: movedPiece.color};
                    playerStats.pawn_promotions++;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∏—á—å—é (—Ç–æ–ª—å–∫–æ –¥–≤–∞ –∫–æ—Ä–æ–ª—è)
            if (checkKingsOnlyDraw()) {
                chessGameOver = true;
                showNotification("–ù–ò–ß–¨–Ø!", "–ù–∞ –¥–æ—Å–∫–µ –æ—Å—Ç–∞–ª–∏—Å—å —Ç–æ–ª—å–∫–æ –¥–≤–∞ –∫–æ—Ä–æ–ª—è");
                updateWelcomeMessage("–ù–∏—á—å—è!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                playerStats.draws++;
                playerStats.games_played++;
                saveProgress();
                return;
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∏—á—å—é (–ø–∞—Ç - –Ω–µ—Ç —Ö–æ–¥–æ–≤ —É –æ–±–æ–∏—Ö)
            if (checkStalemateDraw()) {
                chessGameOver = true;
                showNotification("–ù–ò–ß–¨–Ø!", "–ù–µ—Ç –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤ —É –æ–±–æ–∏—Ö –∏–≥—Ä–æ–∫–æ–≤");
                updateWelcomeMessage("–ù–∏—á—å—è!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                playerStats.draws++;
                playerStats.games_played++;
                saveProgress();
                return;
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —à–∞—Ö
            checkForCheck();
            
            // –ü–µ—Ä–µ–¥–∞–µ–º —Ö–æ–¥ –∏–≥—Ä–æ–∫—É
            currentChessPlayer = playerColor;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞—Ç –∏–ª–∏ –ø–∞—Ç
            if (!hasAnyValidMove(playerColor)) {
                if (isCheck) {
                    chessGameOver = true;
                    chessWinner = aiColor;
                    showCheckmateNotification(aiColor);
                    updateWelcomeMessage("–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                    playerStats.losses++;
                    playerStats.games_played++;
                    saveProgress();
                } else {
                    chessGameOver = true;
                    showNotification("–ü–∞—Ç!", "–ù–∏—á—å—è!");
                    updateWelcomeMessage("–ù–∏—á—å—è!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                    playerStats.draws++;
                    playerStats.games_played++;
                    saveProgress();
                }
                return;
            }
            
            updateWelcomeMessage("–í–∞—à —Ö–æ–¥ (–±–µ–ª—ã–µ)", isCheck ? "–®–ê–•! –ó–∞—â–∏—Ç–∏—Ç–µ –∫–æ—Ä–æ–ª—è" : "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É");
            moveInProgress = false;
        }
        
        function clearCanvas() {
            ctx.fillStyle = `rgb(${BLACK.join(',')})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function gameLoop() {
            clearCanvas();
            
            switch (currentScreen) {
                case SCREENS.menu:
                    drawMenuScreen();
                    break;
                case SCREENS.checkers:
                    drawCheckersScreen();
                    break;
                case SCREENS.chess:
                    drawChessScreen();
                    break;
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function handleResize() {
            scale = 1;
            
            canvas.width = 700;
            canvas.height = 700;
            
            canvasWidth = 700;
            canvasHeight = 700;
            BOARD_SIZE = 550;
            CELL_SIZE = BOARD_SIZE / 8;
        }
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (currentScreen === SCREENS.checkers) {
                handleCheckersClick(x * (canvas.width / rect.width), y * (canvas.height / rect.height));
            } else if (currentScreen === SCREENS.chess) {
                handleChessClick(x * (canvas.width / rect.width), y * (canvas.height / rect.height));
            }
        });
        
        restartBtn.addEventListener('click', () => {
            if (currentScreen === SCREENS.checkers) {
                initCheckers();
            } else if (currentScreen === SCREENS.chess) {
                initChess();
            }
        });
        
        backToModeBtn.addEventListener('click', function() {
            showMenuScreen('gameSelect');
            backToModeBtn.classList.add('hidden');
            restartBtn.classList.add('hidden');
            currentScreen = SCREENS.menu;
            updateWelcomeMessage("–í—ã–±–µ—Ä–∏—Ç–µ –∏–≥—Ä—É", "–®–∞—à–∫–∏ –∏–ª–∏ —à–∞—Ö–º–∞—Ç—ã");
            
            if (currentScreen === SCREENS.checkers) {
                checkersGameOver = true;
            } else if (currentScreen === SCREENS.chess) {
                chessGameOver = true;
            }
            
            // –£–±–∏—Ä–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —à–∞—Ö–µ/–º–∞—Ç–µ
            if (checkmateNotification) {
                document.body.removeChild(checkmateNotification);
                checkmateNotification = null;
            }
            if (checkNotification) {
                document.body.removeChild(checkNotification);
                checkNotification = null;
            }
            if (notificationTimer) {
                clearTimeout(notificationTimer);
            }
        });
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ —Ñ–∏–≥—É—Ä—ã –¥–ª—è –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è –ø–µ—à–∫–∏
        promotionButtons.forEach(button => {
            button.addEventListener('click', function() {
                if (!waitingForPromotion || !promotionPawn) return;
                
                const pieceType = this.getAttribute('data-piece');
                const [row, col] = promotionPawn;
                
                chessBoard[row][col] = {type: pieceType, color: promotionColor};
                playerStats.pawn_promotions++;
                
                waitingForPromotion = false;
                promotionPawn = null;
                promotionColor = null;
                promotionOverlay.classList.add('hidden');
                
                // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ö–æ–¥
                currentChessPlayer = aiColor;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∏—á—å—é (—Ç–æ–ª—å–∫–æ –¥–≤–∞ –∫–æ—Ä–æ–ª—è)
                if (checkKingsOnlyDraw()) {
                    chessGameOver = true;
                    showNotification("–ù–ò–ß–¨–Ø!", "–ù–∞ –¥–æ—Å–∫–µ –æ—Å—Ç–∞–ª–∏—Å—å —Ç–æ–ª—å–∫–æ –¥–≤–∞ –∫–æ—Ä–æ–ª—è");
                    updateWelcomeMessage("–ù–∏—á—å—è!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                    playerStats.draws++;
                    playerStats.games_played++;
                    saveProgress();
                    selectedChessPiece = null;
                    chessPossibleMoves = [];
                    chessCaptureTargets = [];
                    moveInProgress = false;
                    return;
                }
                
                if (!hasAnyValidMove(aiColor)) {
                    checkForCheck();
                    if (isCheck) {
                        chessGameOver = true;
                        chessWinner = playerColor;
                        showCheckmateNotification(playerColor);
                        updateWelcomeMessage("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                        playerStats.wins++;
                        playerStats.games_played++;
                        saveProgress();
                        selectedChessPiece = null;
                        chessPossibleMoves = [];
                        chessCaptureTargets = [];
                        moveInProgress = false;
                        return;
                    } else {
                        chessGameOver = true;
                        showNotification("–ü–∞—Ç!", "–ù–∏—á—å—è!");
                        updateWelcomeMessage("–ù–∏—á—å—è!", "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É");
                        playerStats.draws++;
                        playerStats.games_played++;
                        saveProgress();
                        selectedChessPiece = null;
                        chessPossibleMoves = [];
                        chessCaptureTargets = [];
                        moveInProgress = false;
                        return;
                    }
                }
                
                selectedChessPiece = null;
                chessPossibleMoves = [];
                chessCaptureTargets = [];
                
                updateWelcomeMessage("–•–æ–¥ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ (—á–µ—Ä–Ω—ã–µ)", "–ü–æ–¥–æ–∂–¥–∏—Ç–µ...");
                
                setTimeout(makeAIChessMove, 800);
            });
        });
        
        document.querySelectorAll('.menu-button').forEach(button => {
            button.addEventListener('click', function() {
                const action = this.getAttribute('data-action');
                
                switch(action) {
                    case 'gameSelect':
                        showMenuScreen('gameSelect');
                        backToModeBtn.classList.add('hidden');
                        restartBtn.classList.add('hidden');
                        break;
                    case 'achievements':
                        showMenuScreen('achievements');
                        break;
                    case 'instructions':
                        showMenuScreen('instructions');
                        break;
                    case 'stats':
                        showMenuScreen('stats');
                        break;
                    case 'settings':
                        showMenuScreen('settings');
                        break;
                    case 'back':
                        hideMenu();
                        break;
                    case 'backToMain':
                        showMenuScreen('main');
                        break;
                    case 'resetProgress':
                        if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å –≤–µ—Å—å –ø—Ä–æ–≥—Ä–µ—Å—Å?')) {
                            localStorage.removeItem('project1430_save');
                            localStorage.removeItem('project1430_audio_settings');
                            showNotification("–ü—Ä–æ–≥—Ä–µ—Å—Å —Å–±—Ä–æ—à–µ–Ω", "–ò–≥—Ä–∞ –±—É–¥–µ—Ç –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω–∞");
                            setTimeout(() => {
                                location.reload();
                            }, 1500);
                        }
                        break;
                }
            });
        });
        
        document.querySelectorAll('.game-select-button').forEach(button => {
            button.addEventListener('click', function() {
                const gameType = this.getAttribute('data-game');
                
                switch(gameType) {
                    case 'checkers':
                        updateAchievement('genius');
                        initCheckers();
                        currentScreen = SCREENS.checkers;
                        restartBtn.classList.remove('hidden');
                        break;
                    case 'chess':
                        updateAchievement('genius');
                        initChess();
                        currentScreen = SCREENS.chess;
                        restartBtn.classList.remove('hidden');
                        break;
                }
            });
        });
        
        function initAudioAfterInteraction() {
            initAudio();
            
            document.querySelectorAll('.menu-button, .game-select-button, .action-button').forEach(button => {
                button.addEventListener('click', function() {
                    if (!audioInitialized) {
                        initAudio();
                    }
                });
            });
        }
        
        document.getElementById('musicToggle')?.addEventListener('change', function() {
            toggleMusic(this.checked);
            playerStats.music_toggles++;
            updateAchievement('musician');
            saveProgress();
        });
        
        document.getElementById('musicVolume')?.addEventListener('input', function() {
            audioSettings.musicVolume = this.value / 100;
            updateAudioVolumes();
        });
        
        document.getElementById('soundToggle')?.addEventListener('change', function() {
            audioSettings.soundEnabled = this.checked;
            updateAudioVolumes();
        });
        
        document.getElementById('soundVolume')?.addEventListener('input', function() {
            audioSettings.soundVolume = this.value / 100;
            updateAudioVolumes();
        });
        
        document.getElementById('notificationToggle')?.addEventListener('change', function() {
            audioSettings.notificationEnabled = this.checked;
            updateAudioVolumes();
        });
        
        document.getElementById('notificationVolume')?.addEventListener('input', function() {
            audioSettings.notificationVolume = this.value / 100;
            updateAudioVolumes();
        });
        
        document.getElementById('mandatoryCaptureToggle')?.addEventListener('change', function() {
            audioSettings.mandatoryCapture = this.checked;
            mandatoryCapture = this.checked;
            updateAudioVolumes();
        });
        
        function init() {
            loadProgress();
            loadAudioSettings();
            loadingScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            
            handleResize();
            window.addEventListener('resize', handleResize);
            
            gameLoop();
            
            showMenuScreen('main');
            updateWelcomeMessage("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!", "–í—ã–±–µ—Ä–∏—Ç–µ –∏–≥—Ä—É –≤ –º–µ–Ω—é");
            
            updateAchievement('welcome');
            
            initAudioAfterInteraction();
        }
        
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                if (width < 2 * radius) radius = width / 2;
                if (height < 2 * radius) radius = height / 2;
                this.beginPath();
                this.moveTo(x + radius, y);
                this.arcTo(x + width, y, x + width, y + height, radius);
                this.arcTo(x + width, y + height, x, y + height, radius);
                this.arcTo(x, y + height, x, y, radius);
                this.arcTo(x, y, x + width, y, radius);
                this.closePath();
                return this;
            }
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>